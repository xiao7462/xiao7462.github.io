<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>11. 盛最多水的容器</title>
      <link href="2020/09/18/11.%20%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
      <url>2020/09/18/11.%20%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/">11. 盛最多水的容器</a></h1><p>难度中等1844</p><p>给你 <em>n</em> 个非负整数 <em>a</em>1，<em>a</em>2，…，<em>a</em>n，每个数代表坐标中的一个点 (<em>i</em>, <em>ai</em>) 。在坐标内画 <em>n</em> 条垂直线，垂直线 <em>i</em> 的两个端点分别为 (<em>i</em>, <em>ai</em>) 和 (<em>i</em>, 0)。找出其中的两条线，使得它们与 <em>x</em> 轴共同构成的容器可以容纳最多的水。</p><p><strong>说明：</strong>你不能倾斜容器，且 <em>n</em> 的值至少为 2。</p><p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img"></p><p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><p><strong>示例：</strong></p><pre><code>输入：[1,8,6,2,5,4,8,3,7]输出：49</code></pre><p>通过次数286,240</p><p>提交次数445,940</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>暴力法</p><pre><code class="java">class Solution &#123;    public int maxArea(int[] height) &#123;        int curArea = 0;        int maxArea = 0;        for(int i =0; i &lt; height.length; i++)&#123;            for(int j =i+1; j &lt; height.length; j++)&#123;                curArea = (j-i) * Math.min(height[i], height[j]);                if(curArea &gt; maxArea) maxArea = curArea;            &#125;        &#125;        return maxArea;    &#125;&#125;</code></pre><p>双指针移动， 由于水桶的体积主要取决一最短的边，因此指针在移动的时候，只需要移动最短的边就可以了，而不是双指针都移动</p><pre><code class="java">class Solution &#123;    public int maxArea(int[] height) &#123;        int left = 0;        int right = height.length-1;        int curArea = 0;        int maxArea = 0;        while( left &lt; right)&#123;            curArea = height[left] &lt; height[right] ?                 (right - left) * height[left++]:                (right - left) * height[right--];            if(curArea&gt;maxArea) maxArea = curArea;        &#125;        return maxArea;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>58. 最后一个单词的长度</title>
      <link href="2020/09/17/58.%20%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/"/>
      <url>2020/09/17/58.%20%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="58-最后一个单词的长度"><a href="#58-最后一个单词的长度" class="headerlink" title="58. 最后一个单词的长度"></a><a href="https://leetcode-cn.com/problems/length-of-last-word/">58. 最后一个单词的长度</a></h1><p>难度简单241</p><p>给定一个仅包含大小写字母和空格 <code>&#39; &#39;</code> 的字符串 <code>s</code>，返回其最后一个单词的长度。如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。</p><p>如果不存在最后一个单词，请返回 0 。</p><p><strong>说明：</strong>一个单词是指仅由字母组成、不包含任何空格字符的 <strong>最大子字符串</strong>。</p><p><strong>示例:</strong></p><pre><code>输入: &quot;Hello World&quot;输出: 5</code></pre><p>通过次数125,070</p><p>提交次数371,129</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="python">class Solution:    def lengthOfLastWord(self, s: str) -&gt; int:        s = s.strip()        count = 0        for i in s[::-1]:            if i != &#39; &#39;:                count +=1            else:                break        return count</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1054. 距离相等的条形码</title>
      <link href="2020/09/17/1054.%20%E8%B7%9D%E7%A6%BB%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9D%A1%E5%BD%A2%E7%A0%81/"/>
      <url>2020/09/17/1054.%20%E8%B7%9D%E7%A6%BB%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9D%A1%E5%BD%A2%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="1054-距离相等的条形码"><a href="#1054-距离相等的条形码" class="headerlink" title="1054. 距离相等的条形码"></a><a href="https://leetcode-cn.com/problems/distant-barcodes/">1054. 距离相等的条形码</a></h1><p>难度中等44收藏分享切换为英文关注反馈</p><p>在一个仓库里，有一排条形码，其中第 <code>i</code> 个条形码为 <code>barcodes[i]</code>。</p><p>请你重新排列这些条形码，使其中两个相邻的条形码 <strong>不能</strong> 相等。 你可以返回任何满足该要求的答案，此题保证存在答案。</p><p><strong>示例 1：</strong></p><pre><code>输入：[1,1,1,2,2,2]输出：[2,1,2,1,2,1]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：[1,1,1,1,2,2,3,3]输出：[1,3,1,3,2,1,2,1]</code></pre><p><strong>提示：</strong></p><ol><li><code>1 &lt;= barcodes.length &lt;= 10000</code></li><li><code>1 &lt;= barcodes[i] &lt;= 10000</code></li></ol><p>通过次数5,049</p><p>提交次数14,374</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="python">class Solution:    def rearrangeBarcodes(self, barcodes: List[int]) -&gt; List[int]:        arr = barcodes        for i in range(len(arr)-1):            if arr[i] == arr[i+1] :                for j in range(i,len(arr)):                    if arr[i] != arr[j]:                        arr[i+1],arr[j] = arr[j], arr[i+1]                        break        for i in range(len(arr)-1,-1,-1):            if arr[i] == arr[i-1]:                for j in range(i,-1,-1):                    if arr[i] != arr[j]:                        arr[i-1], arr[j] = arr[j],arr[i-1]                        break        return arr</code></pre><p>从左到右进行遍历，再从右至左遍历</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题 02.01. 移除重复节点</title>
      <link href="2020/09/16/%E9%9D%A2%E8%AF%95%E9%A2%98%2002.01.%20%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/"/>
      <url>2020/09/16/%E9%9D%A2%E8%AF%95%E9%A2%98%2002.01.%20%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="面试题-02-01-移除重复节点"><a href="#面试题-02-01-移除重复节点" class="headerlink" title="面试题 02.01. 移除重复节点"></a><a href="https://leetcode-cn.com/problems/remove-duplicate-node-lcci/">面试题 02.01. 移除重复节点</a></h1><p>难度简单65</p><p>编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。</p><p><strong>示例1:</strong></p><pre><code> 输入：[1, 2, 3, 3, 2, 1] 输出：[1, 2, 3]</code></pre><p><strong>示例2:</strong></p><pre><code> 输入：[1, 1, 1, 1, 2] 输出：[1, 2]</code></pre><p><strong>提示：</strong></p><ol><li>链表长度在[0, 20000]范围内。</li><li>链表元素在[0, 20000]范围内。</li></ol><p><strong>进阶：</strong></p><p>如果不得使用临时缓冲区，该怎么解决？</p><p>通过次数35,417</p><p>提交次数50,758</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="python"># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def removeDuplicateNodes(self, head: ListNode) -&gt; ListNode:        if not head : return None        ret = head        res = [head.val]        while head and head.next:            if head.next.val not in res:                res.append(head.next.val)                head = head.next            else:                head.next = head.next.next        return ret</code></pre><p>注意点： 在移除重复的节点前， 先要把第一个结点的值放到list里面， 再判断下一个结点的值</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>459. 重复的子字符串</title>
      <link href="2020/09/16/459.%20%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>2020/09/16/459.%20%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459. 重复的子字符串"></a><a href="https://leetcode-cn.com/problems/repeated-substring-pattern/">459. 重复的子字符串</a></h1><p>难度简单357</p><p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p><p><strong>示例 1:</strong></p><pre><code>输入: &quot;abab&quot;输出: True解释: 可由子字符串 &quot;ab&quot; 重复两次构成。</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: &quot;aba&quot;输出: False</code></pre><p><strong>示例 3:</strong></p><pre><code>输入: &quot;abcabcabcabc&quot;输出: True解释: 可由子字符串 &quot;abc&quot; 重复四次构成。 (或者子字符串 &quot;abcabc&quot; 重复两次构成。)</code></pre><p>通过次数51,221</p><p>提交次数99,595</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="python">class Solution:    def repeatedSubstringPattern(self, s: str) -&gt; bool:        for i in range(1, len(s)):            if s[0:i] * (len(s)//i) ==s:                return True        return False</code></pre><p>暴力破解</p><p>在真实的面试中遇到过这道题？</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>35.搜索插入位置</title>
      <link href="2020/09/15/35.%20%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
      <url>2020/09/15/35.%20%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a><a href="https://leetcode-cn.com/problems/search-insert-position/">35. 搜索插入位置</a></h1><p>难度简单684收藏分享切换为英文关注反馈</p><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p><strong>示例 1:</strong></p><pre><code class="java">输入: [1,3,5,6], 5输出: 2</code></pre><p><strong>示例 2:</strong></p><pre><code class="java">输入: [1,3,5,6], 2输出: 1</code></pre><p><strong>示例 3:</strong></p><pre><code class="java">输入: [1,3,5,6], 7输出: 4</code></pre><p><strong>示例 4:</strong></p><pre><code class="java">输入: [1,3,5,6], 0输出: 0</code></pre><p>通过次数247,605</p><p>提交次数530,435</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public int searchInsert(int[] nums, int target) &#123;        int left = 0;        int right = nums.length;        while( left &lt; right)&#123;            int mid = left + ( right - left)/ 2;            if(nums[mid] &lt; target)&#123;                left = mid+1;            &#125;else&#123;                right = mid;            &#125;        &#125;        return left;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>26. 删除排序数组中的重复项</title>
      <link href="2020/09/15/26.%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
      <url>2020/09/15/26.%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26. 删除排序数组中的重复项"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">26. 删除排序数组中的重复项</a></h1><p>难度简单1635</p><p>给定一个排序数组，你需要在**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p><p><strong>示例 1:</strong></p><pre><code class="java">给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。</code></pre><p><strong>示例 2:</strong></p><pre><code class="java">给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。</code></pre><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><pre><code class="java">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123;    print(nums[i]);&#125;</code></pre><p>通过次数423,173</p><p>提交次数818,559</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>利用双指针</p><pre><code class="java">class Solution &#123;    public int removeDuplicates(int[] nums) &#123;       //[0,0,1,1,1,2,2,3,3,4]       // p   q        int p = 0;       int q = 1;       while( q &lt; nums.length)&#123;           if( nums[q] &gt; nums[p])&#123;               nums[p+1] = nums[q];               p++;           &#125;           q++;       &#125;        return p+1;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题 17.10. 主要元素</title>
      <link href="2020/09/15/%E9%9D%A2%E8%AF%95%E9%A2%98%2017.10.%20%E4%B8%BB%E8%A6%81%E5%85%83%E7%B4%A0/"/>
      <url>2020/09/15/%E9%9D%A2%E8%AF%95%E9%A2%98%2017.10.%20%E4%B8%BB%E8%A6%81%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="面试题-17-10-主要元素"><a href="#面试题-17-10-主要元素" class="headerlink" title="面试题 17.10. 主要元素"></a><a href="https://leetcode-cn.com/problems/find-majority-element-lcci/">面试题 17.10. 主要元素</a></h1><p>难度简单27</p><p>数组中占比超过一半的元素称之为主要元素。给定一个<strong>整数</strong>数组，找到它的主要元素。若没有，返回-1。</p><p><strong>示例 1：</strong></p><pre><code>输入：[1,2,5,9,5,9,5,5,5]输出：5</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：[3,2]输出：-1</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：[2,2,1,1,1,2,2]输出：2</code></pre><p><strong>说明：</strong><br>你有办法在时间复杂度为 O(N)，空间复杂度为 O(1) 内完成吗？</p><p>通过次数13,487</p><p>提交次数20,963</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public int majorityElement(int[] nums) &#123;        if(nums.length ==1) return nums[0];        int MidLens = nums.length / 2;        HashMap&lt;Integer, Integer&gt; m = new HashMap&lt;&gt;();        for(int i =0; i&lt; nums.length; i++)&#123;            if(m.containsKey( nums[i]))&#123;                Integer temp = m.get(nums[i]);                temp++;                if(temp &gt; MidLens) return nums[i];                m.put(nums[i], temp);            &#125;else&#123;                m.put(nums[i],1);            &#125;        &#125;        return -1;    &#125;&#125;</code></pre><pre><code class="python">class Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        if len(nums) ==1 : return nums[0]        mid = len(nums) // 2        m = &#123;&#125;        for i in nums:            if i in m:                count = m[i]                count +=1                if(count &gt; mid): return i                m[i] = count             else:                m[i] = 1        return -1</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1260. 二维网格迁移</title>
      <link href="2020/09/14/1260.%20%E4%BA%8C%E7%BB%B4%E7%BD%91%E6%A0%BC%E8%BF%81%E7%A7%BB/"/>
      <url>2020/09/14/1260.%20%E4%BA%8C%E7%BB%B4%E7%BD%91%E6%A0%BC%E8%BF%81%E7%A7%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="1260-二维网格迁移"><a href="#1260-二维网格迁移" class="headerlink" title="1260. 二维网格迁移"></a><a href="https://leetcode-cn.com/problems/shift-2d-grid/">1260. 二维网格迁移</a></h1><p>难度简单32</p><p>给你一个 <code>m</code> 行 <code>n</code> 列的二维网格 <code>grid</code> 和一个整数 <code>k</code>。你需要将 <code>grid</code> 迁移 <code>k</code> 次。</p><p>每次「迁移」操作将会引发下述活动：</p><ul><li>位于 <code>grid[i][j]</code> 的元素将会移动到 <code>grid[i][j + 1]</code>。</li><li>位于 <code>grid[i][n - 1]</code> 的元素将会移动到 <code>grid[i + 1][0]</code>。</li><li>位于 <code>grid[m - 1][n - 1]</code> 的元素将会移动到 <code>grid[0][0]</code>。</li></ul><p>请你返回 <code>k</code> 次迁移操作后最终得到的 <strong>二维网格</strong>。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/16/e1-1.png" alt="img"></p><pre><code>输入：grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1输出：[[9,1,2],[3,4,5],[6,7,8]]</code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/16/e2-1.png" alt="img"></p><pre><code>输入：grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4输出：[[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9输出：[[1,2,3],[4,5,6],[7,8,9]]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= grid.length &lt;= 50</code></li><li><code>1 &lt;= grid[i].length &lt;= 50</code></li><li><code>-1000 &lt;= grid[i][j] &lt;= 1000</code></li><li><code>0 &lt;= k &lt;= 100</code></li></ul><p>通过次数6,902</p><p>提交次数11,429</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; shiftGrid(int[][] grid, int k) &#123;        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();        int m = grid.length;        int n = grid[0].length;        int[][] ret= new int[m][n];        for(int i =0; i &lt; m;i++)&#123;            for(int j =0; j &lt; n; j++)&#123;                ret[((j + k )/n +i) % m  ][ (j +k) % n] = grid[i][j];            &#125;        &#125;        for(int i =0 ; i &lt; ret.length;i++)&#123;            List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();            for(int j=0; j&lt; ret[0].length; j++)&#123;                temp.add(ret[i][j]);            &#125;            res.add(temp);        &#125;        return res;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>225. 用队列实现栈</title>
      <link href="2020/09/14/225.%20%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
      <url>2020/09/14/225.%20%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h1><p>难度简单223收藏分享切换为英文关注反馈</p><p>使用队列实现栈的下列操作：</p><ul><li>push(x) – 元素 x 入栈</li><li>pop() – 移除栈顶元素</li><li>top() – 获取栈顶元素</li><li>empty() – 返回栈是否为空</li></ul><p><strong>注意:</strong></p><ul><li>你只能使用队列的基本操作– 也就是 <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code>, 和 <code>is empty</code> 这些操作是合法的。</li><li>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li><li>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</li></ul><p>通过次数72,158</p><p>提交次数110,101</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class MyStack &#123;    LinkedList&lt;Integer&gt; queue1 = new LinkedList&lt;&gt;();    LinkedList&lt;Integer&gt; queue2 = new LinkedList&lt;&gt;();    /** Initialize your data structure here. */    public MyStack() &#123;    &#125;    /** Push element x onto stack. */    public void push(int x) &#123;        queue1.add(x);    &#125;    /** Removes the element on top of the stack and returns that element. */    public int pop() &#123;        while(queue1.size() &gt;1)&#123;            queue2.add(queue1.pollFirst());        &#125;        Integer ret = queue1.pollFirst();        while(!queue2.isEmpty())&#123;            queue1.add(queue2.pollFirst());        &#125;        return ret;    &#125;    /** Get the top element. */    public int top() &#123;        while(queue1.size() &gt;1)&#123;            queue2.add(queue1.pollFirst());        &#125;        Integer ret = queue1.peekFirst();        queue2.add(queue1.pollFirst());        while(!queue2.isEmpty())&#123;            queue1.add(queue2.pollFirst());        &#125;        return ret;    &#125;    /** Returns whether the stack is empty. */    public boolean empty() &#123;        return queue1.isEmpty();    &#125;&#125;/** * Your MyStack object will be instantiated and called as such: * MyStack obj = new MyStack(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.top(); * boolean param_4 = obj.empty(); */</code></pre><p>利用双队列来模拟栈</p><p>注意点， 始终保持queue1为主队列</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 栈，队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1576. 替换所有的问号</title>
      <link href="2020/09/14/1576.%20%E6%9B%BF%E6%8D%A2%E6%89%80%E6%9C%89%E7%9A%84%E9%97%AE%E5%8F%B7/"/>
      <url>2020/09/14/1576.%20%E6%9B%BF%E6%8D%A2%E6%89%80%E6%9C%89%E7%9A%84%E9%97%AE%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="1576-替换所有的问号"><a href="#1576-替换所有的问号" class="headerlink" title="1576. 替换所有的问号"></a><a href="https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/">1576. 替换所有的问号</a></h1><p>难度简单5收藏分享切换为英文关注反馈</p><p>给你一个仅包含小写英文字母和 <code>&#39;?&#39;</code> 字符的字符串 <code>s</code>，请你将所有的 <code>&#39;?&#39;</code> 转换为若干小写字母，使最终的字符串不包含任何 <strong>连续重复</strong> 的字符。</p><p>注意：你 <strong>不能</strong> 修改非 <code>&#39;?&#39;</code> 字符。</p><p>题目测试用例保证 <strong>除</strong> <code>&#39;?&#39;</code> 字符 <strong>之外</strong>，不存在连续重复的字符。</p><p>在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。</p><p><strong>示例 1：</strong></p><pre><code class="java">输入：s = &quot;?zs&quot;输出：&quot;azs&quot;解释：该示例共有 25 种解决方案，从 &quot;azs&quot; 到 &quot;yzs&quot; 都是符合题目要求的。只有 &quot;z&quot; 是无效的修改，因为字符串 &quot;zzs&quot; 中有连续重复的两个 &#39;z&#39; 。</code></pre><p><strong>示例 2：</strong></p><pre><code class="java">输入：s = &quot;ubv?w&quot;输出：&quot;ubvaw&quot;解释：该示例共有 24 种解决方案，只有替换成 &quot;v&quot; 和 &quot;w&quot; 不符合题目要求。因为 &quot;ubvvw&quot; 和 &quot;ubvww&quot; 都包含连续重复的字符。</code></pre><p><strong>示例 3：</strong></p><pre><code class="java">输入：s = &quot;j?qg??b&quot;输出：&quot;jaqgacb&quot;</code></pre><p><strong>示例 4：</strong></p><pre><code class="java">输入：s = &quot;??yw?ipkj?&quot;输出：&quot;acywaipkja&quot;</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> 仅包含小写英文字母和 <code>&#39;?&#39;</code> 字符</li></ul><p>通过次数5,305</p><p>提交次数10,740</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public String modifyString(String s) &#123;        char[] str = s.toCharArray();        char[] strList = &#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;g&#39;,&#39;i&#39;,&#39;j&#39;,&#39;k&#39;,&#39;l&#39;,                &#39;m&#39;,&#39;n&#39;,&#39;o&#39;,&#39;p&#39;,&#39;q&#39;,                &#39;r&#39;,&#39;s&#39;,&#39;t&#39;,&#39;u&#39;,&#39;v&#39;,&#39;w&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;&#125;;        for( int i=0; i &lt; str.length; i++)&#123;            if(str[i] ==&#39;?&#39;)&#123;                char l;                char r;                if(i==0 )&#123;                    l =  &#39; &#39;;                &#125;else&#123;                    l = str[i-1];                &#125;                if(i == str.length-1 )&#123;                    r = &#39; &#39;;                &#125;else&#123;                    r = str[i+1];                &#125;                str[i] = &#39;a&#39;;                for(int j =1; j &lt; strList.length;j++)&#123;                    if( l == str[i] || r == str[i])&#123;                        str[i] = strList[j];                    &#125;else&#123;                        break;                    &#125;                &#125;            &#125;        &#125;        return new String(str);    &#125;&#125;</code></pre><p>关键点：</p><ol><li>遍历的时候，主要将左右边界进行初始化判断</li><li>对于<code>?</code>被替换的值，可以初始化为<code>a</code></li></ol><p>优化解法</p><pre><code class="java">class Solution &#123;    public String modifyString(String s) &#123;        char[] chars = s.toCharArray();        for (int i = 0; i &lt; chars.length; i++) &#123;            if (chars[i] == &#39;?&#39;) &#123;                //前面一个字符  如果当前是第0个的话 字符就为‘ ’                char ahead = i == 0 ? &#39; &#39; : chars[i - 1];                //后面一个字符  如果当前是最后一个的话 字符就为‘ ’                char behind  = i == chars.length - 1 ? &#39; &#39; : chars[i + 1];                //从a开始比较  如果对于前面或者后面的话 就+1                char temp = &#39;a&#39;;                while (temp == ahead || temp == behind ) &#123;                    temp++;                &#125;                //找到目标字符后 做替换                chars[i] = temp;            &#125;        &#125;        return new String(chars);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
