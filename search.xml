<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>1260. 二维网格迁移</title>
      <link href="2020/09/14/1260.%20%E4%BA%8C%E7%BB%B4%E7%BD%91%E6%A0%BC%E8%BF%81%E7%A7%BB/"/>
      <url>2020/09/14/1260.%20%E4%BA%8C%E7%BB%B4%E7%BD%91%E6%A0%BC%E8%BF%81%E7%A7%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="1260-二维网格迁移"><a href="#1260-二维网格迁移" class="headerlink" title="1260. 二维网格迁移"></a><a href="https://leetcode-cn.com/problems/shift-2d-grid/">1260. 二维网格迁移</a></h1><p>难度简单32</p><p>给你一个 <code>m</code> 行 <code>n</code> 列的二维网格 <code>grid</code> 和一个整数 <code>k</code>。你需要将 <code>grid</code> 迁移 <code>k</code> 次。</p><p>每次「迁移」操作将会引发下述活动：</p><ul><li>位于 <code>grid[i][j]</code> 的元素将会移动到 <code>grid[i][j + 1]</code>。</li><li>位于 <code>grid[i][n - 1]</code> 的元素将会移动到 <code>grid[i + 1][0]</code>。</li><li>位于 <code>grid[m - 1][n - 1]</code> 的元素将会移动到 <code>grid[0][0]</code>。</li></ul><p>请你返回 <code>k</code> 次迁移操作后最终得到的 <strong>二维网格</strong>。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/16/e1-1.png" alt="img"></p><pre><code>输入：grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1输出：[[9,1,2],[3,4,5],[6,7,8]]</code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/16/e2-1.png" alt="img"></p><pre><code>输入：grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4输出：[[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9输出：[[1,2,3],[4,5,6],[7,8,9]]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= grid.length &lt;= 50</code></li><li><code>1 &lt;= grid[i].length &lt;= 50</code></li><li><code>-1000 &lt;= grid[i][j] &lt;= 1000</code></li><li><code>0 &lt;= k &lt;= 100</code></li></ul><p>通过次数6,902</p><p>提交次数11,429</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; shiftGrid(int[][] grid, int k) &#123;        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();        int m = grid.length;        int n = grid[0].length;        int[][] ret= new int[m][n];        for(int i =0; i &lt; m;i++)&#123;            for(int j =0; j &lt; n; j++)&#123;                ret[((j + k )/n +i) % m  ][ (j +k) % n] = grid[i][j];            &#125;        &#125;        for(int i =0 ; i &lt; ret.length;i++)&#123;            List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();            for(int j=0; j&lt; ret[0].length; j++)&#123;                temp.add(ret[i][j]);            &#125;            res.add(temp);        &#125;        return res;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>225. 用队列实现栈</title>
      <link href="2020/09/14/225.%20%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
      <url>2020/09/14/225.%20%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h1><p>难度简单223收藏分享切换为英文关注反馈</p><p>使用队列实现栈的下列操作：</p><ul><li>push(x) – 元素 x 入栈</li><li>pop() – 移除栈顶元素</li><li>top() – 获取栈顶元素</li><li>empty() – 返回栈是否为空</li></ul><p><strong>注意:</strong></p><ul><li>你只能使用队列的基本操作– 也就是 <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code>, 和 <code>is empty</code> 这些操作是合法的。</li><li>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li><li>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</li></ul><p>通过次数72,158</p><p>提交次数110,101</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class MyStack &#123;    LinkedList&lt;Integer&gt; queue1 = new LinkedList&lt;&gt;();    LinkedList&lt;Integer&gt; queue2 = new LinkedList&lt;&gt;();    /** Initialize your data structure here. */    public MyStack() &#123;    &#125;    /** Push element x onto stack. */    public void push(int x) &#123;        queue1.add(x);    &#125;    /** Removes the element on top of the stack and returns that element. */    public int pop() &#123;        while(queue1.size() &gt;1)&#123;            queue2.add(queue1.pollFirst());        &#125;        Integer ret = queue1.pollFirst();        while(!queue2.isEmpty())&#123;            queue1.add(queue2.pollFirst());        &#125;        return ret;    &#125;    /** Get the top element. */    public int top() &#123;        while(queue1.size() &gt;1)&#123;            queue2.add(queue1.pollFirst());        &#125;        Integer ret = queue1.peekFirst();        queue2.add(queue1.pollFirst());        while(!queue2.isEmpty())&#123;            queue1.add(queue2.pollFirst());        &#125;        return ret;    &#125;    /** Returns whether the stack is empty. */    public boolean empty() &#123;        return queue1.isEmpty();    &#125;&#125;/** * Your MyStack object will be instantiated and called as such: * MyStack obj = new MyStack(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.top(); * boolean param_4 = obj.empty(); */</code></pre><p>利用双队列来模拟栈</p><p>注意点， 始终保持queue1为主队列</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 栈，队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1576. 替换所有的问号</title>
      <link href="2020/09/14/1576.%20%E6%9B%BF%E6%8D%A2%E6%89%80%E6%9C%89%E7%9A%84%E9%97%AE%E5%8F%B7/"/>
      <url>2020/09/14/1576.%20%E6%9B%BF%E6%8D%A2%E6%89%80%E6%9C%89%E7%9A%84%E9%97%AE%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="1576-替换所有的问号"><a href="#1576-替换所有的问号" class="headerlink" title="1576. 替换所有的问号"></a><a href="https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/">1576. 替换所有的问号</a></h1><p>难度简单5收藏分享切换为英文关注反馈</p><p>给你一个仅包含小写英文字母和 <code>&#39;?&#39;</code> 字符的字符串 <code>s</code>，请你将所有的 <code>&#39;?&#39;</code> 转换为若干小写字母，使最终的字符串不包含任何 <strong>连续重复</strong> 的字符。</p><p>注意：你 <strong>不能</strong> 修改非 <code>&#39;?&#39;</code> 字符。</p><p>题目测试用例保证 <strong>除</strong> <code>&#39;?&#39;</code> 字符 <strong>之外</strong>，不存在连续重复的字符。</p><p>在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。</p><p><strong>示例 1：</strong></p><pre><code class="java">输入：s = &quot;?zs&quot;输出：&quot;azs&quot;解释：该示例共有 25 种解决方案，从 &quot;azs&quot; 到 &quot;yzs&quot; 都是符合题目要求的。只有 &quot;z&quot; 是无效的修改，因为字符串 &quot;zzs&quot; 中有连续重复的两个 &#39;z&#39; 。</code></pre><p><strong>示例 2：</strong></p><pre><code class="java">输入：s = &quot;ubv?w&quot;输出：&quot;ubvaw&quot;解释：该示例共有 24 种解决方案，只有替换成 &quot;v&quot; 和 &quot;w&quot; 不符合题目要求。因为 &quot;ubvvw&quot; 和 &quot;ubvww&quot; 都包含连续重复的字符。</code></pre><p><strong>示例 3：</strong></p><pre><code class="java">输入：s = &quot;j?qg??b&quot;输出：&quot;jaqgacb&quot;</code></pre><p><strong>示例 4：</strong></p><pre><code class="java">输入：s = &quot;??yw?ipkj?&quot;输出：&quot;acywaipkja&quot;</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> 仅包含小写英文字母和 <code>&#39;?&#39;</code> 字符</li></ul><p>通过次数5,305</p><p>提交次数10,740</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public String modifyString(String s) &#123;        char[] str = s.toCharArray();        char[] strList = &#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;g&#39;,&#39;i&#39;,&#39;j&#39;,&#39;k&#39;,&#39;l&#39;,                &#39;m&#39;,&#39;n&#39;,&#39;o&#39;,&#39;p&#39;,&#39;q&#39;,                &#39;r&#39;,&#39;s&#39;,&#39;t&#39;,&#39;u&#39;,&#39;v&#39;,&#39;w&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;&#125;;        for( int i=0; i &lt; str.length; i++)&#123;            if(str[i] ==&#39;?&#39;)&#123;                char l;                char r;                if(i==0 )&#123;                    l =  &#39; &#39;;                &#125;else&#123;                    l = str[i-1];                &#125;                if(i == str.length-1 )&#123;                    r = &#39; &#39;;                &#125;else&#123;                    r = str[i+1];                &#125;                str[i] = &#39;a&#39;;                for(int j =1; j &lt; strList.length;j++)&#123;                    if( l == str[i] || r == str[i])&#123;                        str[i] = strList[j];                    &#125;else&#123;                        break;                    &#125;                &#125;            &#125;        &#125;        return new String(str);    &#125;&#125;</code></pre><p>关键点：</p><ol><li>遍历的时候，主要将左右边界进行初始化判断</li><li>对于<code>?</code>被替换的值，可以初始化为<code>a</code></li></ol><p>优化解法</p><pre><code class="java">class Solution &#123;    public String modifyString(String s) &#123;        char[] chars = s.toCharArray();        for (int i = 0; i &lt; chars.length; i++) &#123;            if (chars[i] == &#39;?&#39;) &#123;                //前面一个字符  如果当前是第0个的话 字符就为‘ ’                char ahead = i == 0 ? &#39; &#39; : chars[i - 1];                //后面一个字符  如果当前是最后一个的话 字符就为‘ ’                char behind  = i == chars.length - 1 ? &#39; &#39; : chars[i + 1];                //从a开始比较  如果对于前面或者后面的话 就+1                char temp = &#39;a&#39;;                while (temp == ahead || temp == behind ) &#123;                    temp++;                &#125;                //找到目标字符后 做替换                chars[i] = temp;            &#125;        &#125;        return new String(chars);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
