<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>200. 岛屿数量</title>
      <link href="2021/05/03/200.%20%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/"/>
      <url>2021/05/03/200.%20%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a></h1><p>难度中等1136收藏分享切换为英文接收动态反馈</p><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p><strong>示例 1：</strong></p><pre><code class="java">输入：grid = [  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]]输出：1</code></pre><p><strong>示例 2：</strong></p><pre><code class="java">输入：grid = [  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]]输出：3</code></pre><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 300</code></li><li><code>grid[i][j]</code> 的值为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    int[][] direction = &#123;&#123;-1,0&#125;, &#123;1,0&#125;, &#123;0,1&#125;, &#123;0,-1&#125;&#125;;    public int numIslands(char[][] grid) &#123;        int nums = 0;        for(int i = 0; i &lt; grid.length; i++) &#123;            for(int j = 0; j &lt; grid[0].length; j++) &#123;                if (grid[i][j] == &#39;1&#39;) &#123;                    bfs(grid, i, j);                    nums++;                &#125;            &#125;        &#125;        return nums;    &#125;    public void bfs(char[][] grid, int i, int j) &#123;        if (!isInGrid(grid, i, j)) return;        if (grid[i][j] != &#39;1&#39;) return ;        grid[i][j] = &#39;2&#39;;        for(int[] dir : direction) &#123;            bfs(grid, i + dir[0], j + dir[1]);        &#125;    &#125;    boolean isInGrid(char[][] grid, int i ,int j)&#123;        return i &gt;= 0 &amp;&amp; i &lt; grid.length &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; grid[0].length;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> bfs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>553. 最优除法</title>
      <link href="2020/12/08/553.%20%E6%9C%80%E4%BC%98%E9%99%A4%E6%B3%95/"/>
      <url>2020/12/08/553.%20%E6%9C%80%E4%BC%98%E9%99%A4%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="553-最优除法"><a href="#553-最优除法" class="headerlink" title="553. 最优除法"></a><a href="https://leetcode-cn.com/problems/optimal-division/">553. 最优除法</a></h1><p>难度中等54</p><p>给定一组<strong>正整数，</strong>相邻的整数之间将会进行浮点除法操作。例如， [2,3,4] -&gt; 2 / 3 / 4 。</p><p>但是，你可以在任意位置添加任意数目的括号，来改变算数的优先级。你需要找出怎么添加括号，才能得到<strong>最大的</strong>结果，并且返回相应的字符串格式的表达式。<strong>你的表达式不应该含有冗余的括号。</strong></p><p><strong>示例：</strong></p><pre><code class="python">输入: [1000,100,10,2]输出: &quot;1000/(100/10/2)&quot;解释:1000/(100/10/2) = 1000/((100/10)/2) = 200但是，以下加粗的括号 &quot;1000/((100/10)/2)&quot; 是冗余的，因为他们并不影响操作的优先级，所以你需要返回 &quot;1000/(100/10/2)&quot;。其他用例:1000/(100/10)/2 = 501000/(100/(10/2)) = 501000/100/10/2 = 0.51000/100/(10/2) = 2</code></pre><p><strong>说明:</strong></p><ol><li>输入数组的长度在 [1, 10] 之间。</li><li>数组中每个元素的大小都在 [2, 1000] 之间。</li><li>每个测试用例只有一个最优除法解。</li></ol><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="python">class Solution:    def optimalDivision(self, nums: List[int]) -&gt; str:        n = len(nums)        if n == 0 : return &quot;&quot;        if n == 1 : return str(nums[0])        if n == 2 : return str(nums[0]) + &#39;/&#39; + str(nums[1])        res = &quot;&quot;        res += str(nums[0])        res += &#39;/(&#39;        for i in range(1, len(nums)):            if i != len(nums) -1 :                res += str(nums[i]) + &#39;/&#39;            else:                res += str(nums[i])        res += &#39;)&#39;        return res</code></pre><p>因为是正整数，无论数组为什么，最大数为 <code>nums[0] /(nums[1]/nums[2]/....nums[n-1])</code></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题 16.26. 计算器</title>
      <link href="2020/12/06/%E9%9D%A2%E8%AF%95%E9%A2%98%2016.26.%20%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
      <url>2020/12/06/%E9%9D%A2%E8%AF%95%E9%A2%98%2016.26.%20%E8%AE%A1%E7%AE%97%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="面试题-16-26-计算器"><a href="#面试题-16-26-计算器" class="headerlink" title="面试题 16.26. 计算器"></a><a href="https://leetcode-cn.com/problems/calculator-lcci/">面试题 16.26. 计算器</a></h1><p>难度中等22收藏分享切换为英文接收动态反馈</p><p>给定一个包含正整数、加(+)、减(-)、乘(*)、除(/)的算数表达式(括号除外)，计算其结果。</p><p>表达式仅包含非负整数，<code>+</code>， <code>-</code> ，<code>*</code>，<code>/</code> 四种运算符和空格 <code> </code>。 整数除法仅保留整数部分。</p><p><strong>示例 1:</strong></p><pre><code>输入: &quot;3+2*2&quot;输出: 7</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: &quot; 3/2 &quot;输出: 1</code></pre><p><strong>示例 3:</strong></p><pre><code>输入: &quot; 3+5 / 2 &quot;输出: 5</code></pre><p><strong>说明：</strong></p><ul><li>你可以假设所给定的表达式都是有效的。</li><li>请<strong>不要</strong>使用内置的库函数 <code>eval</code>。</li></ul><p>通过次数6,509</p><p>提交次数17,412</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="python">class Solution:    def calculate(self, s: str) -&gt; int:        s = list(s)        stack = []        num = 0        opt = &quot;+&quot; # 第一个数可以看成是 [0] + num , 也就是第一个数一定是正数        opreate = [&quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;]        for i in range( len(s)):            # 注意是弹栈头的方式            ch = s.pop(0)            # 如果是数字则继续加， 可能有多位            if ch.isdigit():                num = num * 10 + int(ch)            # 如果题目中带() ,则 对()中的表达式进行递归操作            if ch == &#39;(&#39;:                self.calculate(s)            if ch in opreate or not s or ch == &#39;)&#39;:                # opt保存的是上一个非数字的符号，                # stack.pop() 保存的是 上一个非数组符号的左边的数                # num 保存的是上一个非数组符号的右边的数                # 最后计算他们2个 值                if opt == &quot;+&quot;:                    stack.append( num)                if opt == &quot;-&quot;:                    stack.append(-num)                if opt == &#39;*&#39;:                    stack.append( stack.pop() * num)                if opt == &quot;/&quot;:                    stack.append( int ( stack.pop() / num))                 # 计算完之后，再讲计算式保存为当前的计算符                opt = ch                 # 将num清0                num = 0;            if ch == &#39;)&#39;:                break        return sum(stack)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1668. 最大重复子字符串</title>
      <link href="2020/12/05/1668.%20%E6%9C%80%E5%A4%A7%E9%87%8D%E5%A4%8D%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>2020/12/05/1668.%20%E6%9C%80%E5%A4%A7%E9%87%8D%E5%A4%8D%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h4 id="1668-最大重复子字符串"><a href="#1668-最大重复子字符串" class="headerlink" title="1668. 最大重复子字符串"></a><a href="https://leetcode-cn.com/problems/maximum-repeating-substring/">1668. 最大重复子字符串</a></h4><p>难度简单3收藏分享切换为英文接收动态反馈</p><p>给你一个字符串 <code>sequence</code> ，如果字符串 <code>word</code> 连续重复 <code>k</code> 次形成的字符串是 <code>sequence</code> 的一个子字符串，那么单词 <code>word</code> 的 <strong>重复值为 <code>k</code></strong> 。单词 <code>word</code> 的 <strong>最**</strong>大重复值** 是单词 <code>word</code> 在 <code>sequence</code> 中最大的重复值。如果 <code>word</code> 不是 <code>sequence</code> 的子串，那么重复值 <code>k</code> 为 <code>0</code> 。</p><p>给你一个字符串 <code>sequence</code> 和 <code>word</code> ，请你返回 <strong>最大重复值 <code>k</code></strong> 。</p><p><strong>示例 1：</strong></p><pre><code class="python">输入：sequence = &quot;ababc&quot;, word = &quot;ab&quot;输出：2解释：&quot;abab&quot; 是 &quot;ababc&quot; 的子字符串。</code></pre><p><strong>示例 2：</strong></p><pre><code class="python">输入：sequence = &quot;ababc&quot;, word = &quot;ba&quot;输出：1解释：&quot;ba&quot; 是 &quot;ababc&quot; 的子字符串，但 &quot;baba&quot; 不是 &quot;ababc&quot; 的子字符串。</code></pre><p><strong>示例 3：</strong></p><pre><code class="python">输入：sequence = &quot;ababc&quot;, word = &quot;ac&quot;输出：0解释：&quot;ac&quot; 不是 &quot;ababc&quot; 的子字符串。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= sequence.length &lt;= 100</code></li><li><code>1 &lt;= word.length &lt;= 100</code></li><li><code>sequence</code> 和 <code>word</code> 都只包含小写英文字母。</li></ul><p>通过次数2,231</p><p>提交次数5,175</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="python">class Solution:    def maxRepeating(self, sequence: str, word: str) -&gt; int:        res = 0        while word * (res+1) in sequence:            res+=1        return res</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>816. 模糊坐标</title>
      <link href="2020/12/05/816.%20%E6%A8%A1%E7%B3%8A%E5%9D%90%E6%A0%87/"/>
      <url>2020/12/05/816.%20%E6%A8%A1%E7%B3%8A%E5%9D%90%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<h4 id="816-模糊坐标"><a href="#816-模糊坐标" class="headerlink" title="816. 模糊坐标"></a><a href="https://leetcode-cn.com/problems/ambiguous-coordinates/">816. 模糊坐标</a></h4><p>难度中等27</p><p>我们有一些二维坐标，如 <code>&quot;(1, 3)&quot;</code> 或 <code>&quot;(2, 0.5)&quot;</code>，然后我们移除所有逗号，小数点和空格，得到一个字符串<code>S</code>。返回所有可能的原始字符串到一个列表中。</p><p>原始的坐标表示法不会存在多余的零，所以不会出现类似于”00”, “0.0”, “0.00”, “1.0”, “001”, “00.01”或一些其他更小的数来表示坐标。此外，一个小数点前至少存在一个数，所以也不会出现“.1”形式的数字。</p><p>最后返回的列表可以是任意顺序的。而且注意返回的两个数字中间（逗号之后）都有一个空格。</p><pre><code class="python">示例 1:输入: &quot;(123)&quot;输出: [&quot;(1, 23)&quot;, &quot;(12, 3)&quot;, &quot;(1.2, 3)&quot;, &quot;(1, 2.3)&quot;]示例 2:输入: &quot;(00011)&quot;输出:  [&quot;(0.001, 1)&quot;, &quot;(0, 0.011)&quot;]解释: 0.0, 00, 0001 或 00.01 是不被允许的。示例 3:输入: &quot;(0123)&quot;输出: [&quot;(0, 123)&quot;, &quot;(0, 12.3)&quot;, &quot;(0, 1.23)&quot;, &quot;(0.1, 23)&quot;, &quot;(0.1, 2.3)&quot;, &quot;(0.12, 3)&quot;]示例 4:输入: &quot;(100)&quot;输出: [(10, 0)]解释: 1.0 是不被允许的。</code></pre><p><strong>提示:</strong></p><ul><li><code>4 &lt;= S.length &lt;= 12</code>.</li><li><code>S[0]</code> = “(“, <code>S[S.length - 1]</code> = “)”, 且字符串 <code>S</code> 中的其他元素都是数字。</li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="python">class Solution:    def ambiguousCoordinates(self, S: str) -&gt; List[str]:        res = []        s = S[1:-1]        for i in range(1,len(s)):            x = self.make( s[:i])            y = self.make( s[i:])            for m in x:                for n in y:                    res.append( &quot;(&#123;&#125;, &#123;&#125;)&quot;.format(m,n))        return res    #如果第一个字符为0 那么 要么这个数字是 0 要么这个数字是 0.xxx    #如果结尾是0 那么这个数不能是是小数    def make(self, s):        # 如果 s 是以0开头的，后面非0        if s !=&#39;0&#39; and s[0] ==&#39;0&#39;:            return [ &#39;0.&#39; + s[1:]] if s[-1] != &#39;0&#39; else []        # 如果 s的最后为0， 则直接返回        if s[-1] ==&#39;0&#39;:            return [s]        res = [s]        for i in range( 1,len(s)):            res.append( s[:i] +&#39;.&#39; +s[i:])        return res</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1249. 移除无效的括号</title>
      <link href="2020/12/03/1249.%20%E7%A7%BB%E9%99%A4%E6%97%A0%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
      <url>2020/12/03/1249.%20%E7%A7%BB%E9%99%A4%E6%97%A0%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h4 id="1249-移除无效的括号"><a href="#1249-移除无效的括号" class="headerlink" title="1249. 移除无效的括号"></a><a href="https://leetcode-cn.com/problems/minimum-remove-to-make-valid-parentheses/">1249. 移除无效的括号</a></h4><p>难度中等68</p><p>给你一个由 <code>&#39;(&#39;</code>、<code>&#39;)&#39;</code> 和小写字母组成的字符串 <code>s</code>。</p><p>你需要从字符串中删除最少数目的 <code>&#39;(&#39;</code> 或者 <code>&#39;)&#39;</code> （可以删除任意位置的括号)，使得剩下的「括号字符串」有效。</p><p>请返回任意一个合法字符串。</p><p>有效「括号字符串」应当符合以下 <strong>任意一条</strong> 要求：</p><ul><li>空字符串或只包含小写字母的字符串</li><li>可以被写作 <code>AB</code>（<code>A</code> 连接 <code>B</code>）的字符串，其中 <code>A</code> 和 <code>B</code> 都是有效「括号字符串」</li><li>可以被写作 <code>(A)</code> 的字符串，其中 <code>A</code> 是一个有效的「括号字符串」</li></ul><p><strong>示例 1：</strong></p><pre><code class="python">输入：s = &quot;lee(t(c)o)de)&quot;输出：&quot;lee(t(c)o)de&quot;解释：&quot;lee(t(co)de)&quot; , &quot;lee(t(c)ode)&quot; 也是一个可行答案。</code></pre><p><strong>示例 2：</strong></p><pre><code class="python">输入：s = &quot;a)b(c)d&quot;输出：&quot;ab(c)d&quot;</code></pre><p><strong>示例 3：</strong></p><pre><code class="python">输入：s = &quot;))((&quot;输出：&quot;&quot;解释：空字符串也是有效的</code></pre><p><strong>示例 4：</strong></p><pre><code class="python">输入：s = &quot;(a(b(c)d)&quot;输出：&quot;a(b(c)d)&quot;</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 10^5</code></li><li><code>s[i]</code> 可能是 <code>&#39;(&#39;</code>、<code>&#39;)&#39;</code> 或英文小写字母</li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>利用栈保存 括号 和remove数组保存需要删除的索引</p><pre><code class="python">class Solution:    def minRemoveToMakeValid(self, s: str) -&gt; str:        remove = []        stack = []        arr = list(s)        for i in range(len(arr)):            if arr[i] == &#39;(&#39;:                stack.append(arr[i])                remove.append(i)            if arr[i] == &#39;)&#39;:                if len(stack) == 0:                    remove.append(i)                else:                    stack.pop()                    remove.pop()        res = []        for i in range(len(arr)):            if i not in remove:                res.append(s[i])        return &quot;&quot;.join(res)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1328. 破坏回文串</title>
      <link href="2020/12/03/1328.%20%E7%A0%B4%E5%9D%8F%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
      <url>2020/12/03/1328.%20%E7%A0%B4%E5%9D%8F%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h4 id="1328-破坏回文串"><a href="#1328-破坏回文串" class="headerlink" title="1328. 破坏回文串"></a><a href="https://leetcode-cn.com/problems/break-a-palindrome/">1328. 破坏回文串</a></h4><p>难度中等15</p><p>给你一个回文字符串 <code>palindrome</code> ，请你将其中 <strong>一个</strong> 字符用任意小写英文字母替换，使得结果字符串的字典序最小，且 <strong>不是</strong> 回文串。</p><p>请你返回结果字符串。如果无法做到，则返回一个空串。</p><p><strong>示例 1：</strong></p><pre><code class="python">输入：palindrome = &quot;abccba&quot;输出：&quot;aaccba&quot;</code></pre><p><strong>示例 2：</strong></p><pre><code class="python">输入：palindrome = &quot;a&quot;输出：&quot;&quot;</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= palindrome.length &lt;= 1000</code></li><li><code>palindrome</code> 只包含小写英文字母。</li></ul><p>通过次数3,488</p><p>提交次数7,956</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="python">class Solution:    def breakPalindrome(self, palindrome: str) -&gt; str:        if len(palindrome) == 1 or len(palindrome) == 0:            return &quot;&quot;        temp = list(palindrome)        count = 0        for i in range(len(temp)):            char = temp[i]            if temp[i] != &#39;a&#39;:                temp[i] = &#39;a&#39;                # 替换字符后判断是不是回文串                if( temp != temp[::-1]):                    return &#39;&#39;.join(temp)                else:                    temp[i] = char            count+=1        # 如果字符串全部是a ，则直接替换最后一个字符        if( count == len(temp)):            temp[len(temp) -1] = &#39;b&#39;        return &quot;&quot;.join(temp)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1180. 统计只含单一字母的子串</title>
      <link href="2020/11/26/1180.%20%E7%BB%9F%E8%AE%A1%E5%8F%AA%E5%90%AB%E5%8D%95%E4%B8%80%E5%AD%97%E6%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2/"/>
      <url>2020/11/26/1180.%20%E7%BB%9F%E8%AE%A1%E5%8F%AA%E5%90%AB%E5%8D%95%E4%B8%80%E5%AD%97%E6%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h4 id="1180-统计只含单一字母的子串"><a href="#1180-统计只含单一字母的子串" class="headerlink" title="1180. 统计只含单一字母的子串"></a><a href="https://leetcode-cn.com/problems/count-substrings-with-only-one-distinct-letter/">1180. 统计只含单一字母的子串</a></h4><p>难度简单18</p><p>给你一个字符串 <code>S</code>，返回只含 <strong>单一字母</strong> 的子串个数。</p><p><strong>示例 1：</strong></p><pre><code class="java">输入： &quot;aaaba&quot;输出： 8解释： 只含单一字母的子串分别是 &quot;aaa&quot;， &quot;aa&quot;， &quot;a&quot;， &quot;b&quot;。&quot;aaa&quot; 出现 1 次。&quot;aa&quot; 出现 2 次。&quot;a&quot; 出现 4 次。&quot;b&quot; 出现 1 次。所以答案是 1 + 2 + 4 + 1 = 8。</code></pre><p><strong>示例 2:</strong></p><pre><code class="java">输入： &quot;aaaaaaaaaa&quot;输出： 55</code></pre><p><strong>提示：</strong></p><ol><li><code>1 &lt;= S.length &lt;= 1000</code></li><li><code>S[i]</code> 仅由小写英文字母组成。</li></ol><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public int countLetters(String S) &#123;        int res = 0;        int count = 1;        String ss = S + &#39;0&#39;;        char[] temp = ss.toCharArray();        for(int i =0 ; i &lt; temp.length-1; i++)&#123;            if(temp[i] == temp[i+1])&#123;                count++;            &#125;else&#123;                res+=getNum(count);                count = 1;            &#125;        &#125;        return res;    &#125;    public int getNum(int num)&#123;        int count = 0;        while(num &gt;0)&#123;            count+=num;            num--;        &#125;        return count;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>434. 字符串中的单词数</title>
      <link href="2020/10/30/434.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0/"/>
      <url>2020/10/30/434.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="434-字符串中的单词数"><a href="#434-字符串中的单词数" class="headerlink" title="434. 字符串中的单词数"></a><a href="https://leetcode-cn.com/problems/number-of-segments-in-a-string/">434. 字符串中的单词数</a></h1><p>难度简单60收藏分享切换为英文接收动态反馈</p><p>统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。</p><p>请注意，你可以假定字符串里不包括任何不可打印的字符。</p><p><strong>示例:</strong></p><pre><code class="java">输入: &quot;Hello, my name is John&quot;输出: 5解释: 这里的单词是指连续的不是空格的字符，所以 &quot;Hello,&quot; 算作 1 个单词。</code></pre><p>通过次数24,742</p><p>提交次数24,742</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public int countSegments(String s) &#123;        String[] str = s.split(&quot; &quot;);        int count = 0;        for( String i :str)&#123;            if( !&quot;&quot;.equals(i))&#123;                count++;            &#125;        &#125;        return count;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>125. 验证回文串</title>
      <link href="2020/10/30/125%20%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
      <url>2020/10/30/125%20%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125. 验证回文串"></a><a href="https://leetcode-cn.com/problems/valid-palindrome/">125. 验证回文串</a></h1><p>难度简单286收藏分享切换为英文接收动态反馈</p><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p><p><strong>说明：</strong>本题中，我们将空字符串定义为有效的回文串。</p><p><strong>示例 1:</strong></p><pre><code class="java">输入: &quot;A man, a plan, a canal: Panama&quot;输出: true</code></pre><p><strong>示例 2:</strong></p><pre><code class="java">输入: &quot;race a car&quot;输出: false</code></pre><p>通过次数173,071</p><p>提交次数173,071</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public boolean isPalindrome(String s) &#123;        s = s.toLowerCase();        StringBuilder sb = new StringBuilder();        for( char i : s.toCharArray())&#123;            if( Character.isLetterOrDigit(i))&#123;                sb.append(i);            &#125;        &#125;        return sb.toString().equals( sb.reverse().toString());    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1544. 整理字符串</title>
      <link href="2020/10/30/1544.%20%E6%95%B4%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>2020/10/30/1544.%20%E6%95%B4%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="1544-整理字符串"><a href="#1544-整理字符串" class="headerlink" title="1544. 整理字符串"></a><a href="https://leetcode-cn.com/problems/make-the-string-great/">1544. 整理字符串</a></h1><p>难度简单15收藏分享切换为英文接收动态反馈</p><p>给你一个由大小写英文字母组成的字符串 <code>s</code> 。</p><p>一个整理好的字符串中，两个相邻字符 <code>s[i]</code> 和 <code>s[i+1]</code>，其中 <code>0&lt;= i &lt;= s.length-2</code> ，要满足如下条件:</p><ul><li>若 <code>s[i]</code> 是小写字符，则 <code>s[i+1]</code> 不可以是相同的大写字符。</li><li>若 <code>s[i]</code> 是大写字符，则 <code>s[i+1]</code> 不可以是相同的小写字符。</li></ul><p>请你将字符串整理好，每次你都可以从字符串中选出满足上述条件的 <strong>两个相邻</strong> 字符并删除，直到字符串整理好为止。</p><p>请返回整理好的 <strong>字符串</strong> 。题目保证在给出的约束条件下，测试样例对应的答案是唯一的。</p><p><strong>注意：</strong>空字符串也属于整理好的字符串，尽管其中没有任何字符。</p><p><strong>示例 1：</strong></p><pre><code class="java">输入：s = &quot;leEeetcode&quot;输出：&quot;leetcode&quot;解释：无论你第一次选的是 i = 1 还是 i = 2，都会使 &quot;leEeetcode&quot; 缩减为 &quot;leetcode&quot; 。</code></pre><p><strong>示例 2：</strong></p><pre><code class="java">输入：s = &quot;abBAcC&quot;输出：&quot;&quot;解释：存在多种不同情况，但所有的情况都会导致相同的结果。例如：&quot;abBAcC&quot; --&gt; &quot;aAcC&quot; --&gt; &quot;cC&quot; --&gt; &quot;&quot;&quot;abBAcC&quot; --&gt; &quot;abBA&quot; --&gt; &quot;aA&quot; --&gt; &quot;&quot;</code></pre><p><strong>示例 3：</strong></p><pre><code class="java">输入：s = &quot;s&quot;输出：&quot;s&quot;</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> 只包含小写和大写英文字母</li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public String makeGood(String s) &#123;        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();        for(int i = 0; i &lt; s.length(); i++)&#123;            if(!stack.isEmpty())&#123;                if( (s.charAt(i) - stack.peek() == 32) ||(s.charAt(i) - stack.peek() == -32) )&#123;                    stack.pop();                &#125;else&#123;                    stack.push(s.charAt(i));                &#125;            &#125;else&#123;                stack.push( s.charAt(i));            &#125;        &#125;        StringBuilder sb = new StringBuilder();        while( !stack.isEmpty())&#123;            sb.append( stack.pop());        &#125;        return sb.reverse().toString();    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>19. 删除链表的倒数第N个节点</title>
      <link href="2020/10/28/19.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
      <url>2020/10/28/19.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h4 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19. 删除链表的倒数第N个节点"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第N个节点</a></h4><p>难度中等1087收藏分享切换为英文接收动态反馈</p><p>给定一个链表，删除链表的倒数第 <em>n</em> 个节点，并且返回链表的头结点。</p><p><strong>示例：</strong></p><pre><code class="java">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</code></pre><p><strong>说明：</strong></p><p>给定的 <em>n</em> 保证是有效的。</p><p><strong>进阶：</strong></p><p>你能尝试使用一趟扫描实现吗？</p><p>通过次数274,931</p><p>提交次数679,764</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>解题思路<br>本题解采用了 双指针 的思想：</p><blockquote><p>只需要使得 快指针 比 慢指针 快 n个节点 就行<br>之后两个指针同时向后遍历。直到 快指针 到达 链表的最后一个元素，慢指针 即 目标元素</p></blockquote><p>但是需要注意的一点是：</p><blockquote><p>为了防止 删除目标节点 导致 空指针异常，我们需要为原串增加一个 头节点</p></blockquote><pre><code class="java">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123;    public ListNode removeNthFromEnd(ListNode head, int n) &#123;        if( n &lt; 1 || head == null) return head;        ListNode pre = new ListNode();        pre.next = head;        ListNode slow = pre;        ListNode fast = pre;        for(int i = 0; i &lt; n+1; i++)&#123;            fast = fast.next;        &#125;        while( fast != null)&#123;            fast = fast.next;            slow = slow.next;        &#125;        slow.next = slow.next.next;        return pre.next;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 18. 删除链表的节点</title>
      <link href="2020/10/28/%E5%89%91%E6%8C%87%20Offer%2018.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/"/>
      <url>2020/10/28/%E5%89%91%E6%8C%87%20Offer%2018.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h4 id="剑指-Offer-18-删除链表的节点"><a href="#剑指-Offer-18-删除链表的节点" class="headerlink" title="剑指 Offer 18. 删除链表的节点"></a><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/">剑指 Offer 18. 删除链表的节点</a></h4><p>难度简单65</p><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p><p>返回删除后的链表的头节点。</p><p><strong>注意：</strong>此题对比原题有改动</p><p><strong>示例 1:</strong></p><pre><code class="java">输入: head = [4,5,1,9], val = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</code></pre><p><strong>示例 2:</strong></p><pre><code class="java">输入: head = [4,5,1,9], val = 1输出: [4,5,9]解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</code></pre><p><strong>说明：</strong></p><ul><li>题目保证链表中节点的值互不相同</li><li>若使用 C 或 C++ 语言，你不需要 <code>free</code> 或 <code>delete</code> 被删除的节点</li></ul><p>通过次数72,052</p><p>提交次数122,514</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>单指针</p><pre><code class="java">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public ListNode deleteNode(ListNode head, int val) &#123;        if(head.val == val)&#123;            return head.next;        &#125;                ListNode dummy = head;        while( head.next != null)&#123;            if( head.next.val == val)&#123;                head.next = head.next.next;                break;            &#125;            head = head.next;        &#125;        return dummy;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21. 合并两个有序链表</title>
      <link href="2020/10/28/21.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
      <url>2020/10/28/21.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h1><p>难度简单1345收藏分享切换为英文接收动态反馈</p><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p><strong>示例：</strong></p><pre><code class="java">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</code></pre><p>通过次数398,263</p><p>提交次数616,571</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123;    public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;        if( l1 == null) return l2;        if( l2 == null) return l1;        ListNode dummy = new ListNode();        ListNode pre = dummy;        while( l1 != null  &amp;&amp; l2 != null)&#123;            if( l1.val &lt;= l2.val)&#123;                pre.next = l1;                l1 = l1.next;            &#125;else&#123;                pre.next = l2;                l2 = l2.next;            &#125;            pre = pre.next;        &#125;        pre.next = l1 == null ? l2: l1;        return dummy.next;    &#125;&#125;</code></pre><p>因为链表是升序的，我们只需要遍历每个链表的头，比较一下哪个小就把哪个链表的头拿出来放到新的链表中，一直这样循环，直到有一个链表为空，然后我们再把另一个不为空的链表挂到新的链表中。<br>我们就以3→4→7→9和2→5→6两个链表来画个图看一下是怎么合并的</p><p><img src="https://pic.leetcode-cn.com/8056ae02cbcd1b170ef27d7553d0281accfd31f2673353dd6fc472f80301c4f1-image.png" alt="image.png"><br><img src="https://pic.leetcode-cn.com/ceb23158d4d4921dc754fe2e149bbbcfca0a3a13dd63ecc18a2890e4f4254383-image.png" alt="image.png"><br><img src="https://pic.leetcode-cn.com/332476e453a011a1ee83860ae07f6b1795adf361ab04061fefa28f57a2982b1d-image.png" alt="image.png"></p><p>参考： <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/javadai-ma-di-gui-he-fei-di-gui-tu-wen-jiang-jie-b/">https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/javadai-ma-di-gui-he-fei-di-gui-tu-wen-jiang-jie-b/</a>  </p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>867. 转置矩阵</title>
      <link href="2020/10/27/867.%20%E8%BD%AC%E7%BD%AE%E7%9F%A9%E9%98%B5/"/>
      <url>2020/10/27/867.%20%E8%BD%AC%E7%BD%AE%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="867-转置矩阵"><a href="#867-转置矩阵" class="headerlink" title="867. 转置矩阵"></a><a href="https://leetcode-cn.com/problems/transpose-matrix/">867. 转置矩阵</a></h1><p>难度简单116</p><p>给定一个矩阵 <code>A</code>， 返回 <code>A</code> 的转置矩阵。</p><p>矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。</p><p><strong>示例 1：</strong></p><pre><code class="java">输入：[[1,2,3],[4,5,6],[7,8,9]]输出：[[1,4,7],[2,5,8],[3,6,9]]</code></pre><p><strong>示例 2：</strong></p><pre><code class="java">输入：[[1,2,3],[4,5,6]]输出：[[1,4],[2,5],[3,6]]</code></pre><p><strong>提示：</strong></p><ol><li><code>1 &lt;= A.length &lt;= 1000</code></li><li><code>1 &lt;= A[0].length &lt;= 1000</code></li></ol><p>通过次数30,523</p><p>提交次数45,314</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public int[][] transpose(int[][] A) &#123;        int m = A.length;        int n = A[0].length;        int[][] arr = new int[n][m];        //选取第一列        for(int i =0; i &lt; m; i++)&#123;            for( int j = 0; j &lt; n; j++)&#123;                arr[j][i] = A[i][j];             &#125;        &#125;        return arr;    &#125;&#125;</code></pre><p>只要记住，  当前要转换数字的位置 与 转换后的位置  之间的关系， 就可以得出它们之间的转换关系。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>77. 组合</title>
      <link href="2020/10/18/77.%20%E7%BB%84%E5%90%88/"/>
      <url>2020/10/18/77.%20%E7%BB%84%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><a href="https://leetcode-cn.com/problems/combinations/">77. 组合</a></h1><p>难度中等416收藏分享切换为英文接收动态反馈</p><p>给定两个整数 <em>n</em> 和 <em>k</em>，返回 1 … <em>n</em> 中所有可能的 <em>k</em> 个数的组合。</p><p><strong>示例:</strong></p><pre><code class="java">输入: n = 4, k = 2输出:[  [2,4],  [3,4],  [2,3],  [1,2],  [1,3],  [1,4],]</code></pre><p>通过次数109,730</p><p>提交次数144,781</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;        List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();        if( k &lt;=0 || n &lt; k) return res;        traceBack(n, k, 1, new LinkedList&lt;Integer&gt;(), res);        return res;    &#125;    void traceBack(int n , int k,int start, LinkedList&lt;Integer&gt; temp, List&lt;List&lt;Integer&gt;&gt; res)&#123;        if( temp.size() == k)&#123;            res.add(new LinkedList&lt;&gt;(temp));            return;        &#125;        for(int i =start; i &lt;= n; i++)&#123;            temp.add(i);            traceBack(n, k,i+1, temp, res );            temp.pollLast();        &#125;    &#125;&#125;</code></pre><p>如果组合里有 1 ，那么需要在 [2, 3, 4] 里再找 11 个数；<br>如果组合里有 2 ，那么需要在 [3, 4] 里再找 11数。注意：这里不能再考虑 11，因为包含 11 的组合，在第 1 种情况中已经包含。</p><p>作者：liweiwei1419<br>链接：<a href="https://leetcode-cn.com/problems/combinations/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-ma-/">https://leetcode-cn.com/problems/combinations/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-ma-/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>参考</p><blockquote><p>[回溯算法 + 剪枝（Java）](回溯算法 + 剪枝（Java）)</p></blockquote><p>注意遍历的i 应该从 start开始， 并且每次递归都是 i+1 ， 如果直接 <code>temp.contains(i)</code> 进行判空的话，还是会重复</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>针对搜索</p><pre><code class="java">// 从当前搜索起点 begin 遍历到 nfor (int i = begin; i &lt;= n; i++) &#123;    path.addLast(i);    dfs(n, k, i + 1, path, res);    path.removeLast();&#125;</code></pre><p>事实上，如果 n = 7, k = 4，从 55 开始搜索就已经没有意义了，这是因为：即使把 55 选上，后面的数只有 66 和 77，一共就 33 个候选数，凑不出 44 个数的组合。因此，搜索起点有上界，这个上界是多少，可以举几个例子分析。</p><p>容易知道：搜索起点和当前还需要选几个数有关，而当前还需要选几个数与已经选了几个数有关，即与 path 的长度相关。我们举几个例子分析：</p><p>例如：n = 6 ，k = 4。</p><p>path.size() == 1 的时候，接下来要选择 33 个数，搜索起点最大是 44，最后一个被选的组合是 [4, 5, 6]；<br>path.size() == 2 的时候，接下来要选择 22 个数，搜索起点最大是 55，最后一个被选的组合是 [5, 6]；<br>path.size() == 3 的时候，接下来要选择 11 个数，搜索起点最大是 66，最后一个被选的组合是 [6]；</p><p>再如：n = 15 ，k = 4。<br>path.size() == 1 的时候，接下来要选择 33 个数，搜索起点最大是 1313，最后一个被选的是 [13, 14, 15]；<br>path.size() == 2 的时候，接下来要选择 22 个数，搜索起点最大是 1414，最后一个被选的是 [14, 15]；<br>path.size() == 3 的时候，接下来要选择 11 个数，搜索起点最大是 1515，最后一个被选的是 [15]；</p><p>可以归纳出：</p><p>搜索起点的上界 + 接下来要选择的元素个数 - 1 = n<br>其中，接下来要选择的元素个数 = k - path.size()，整理得到：</p><p>搜索起点的上界 = <code>n - (k - path.size()) + 1</code><br>所以，我们的剪枝过程就是：把<code> i &lt;= n</code> 改成<code> i &lt;= n - (k - path.size()) + 1</code> ：</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 回溯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20. 有效的括号</title>
      <link href="2020/10/17/20.%20%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
      <url>2020/10/17/20.%20%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h4 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号</a></h4><p>难度简单1920收藏分享切换为英文接收动态反馈</p><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><p>注意空字符串可被认为是有效字符串。</p><p><strong>示例 1:</strong></p><pre><code class="java">输入: &quot;()&quot;输出: true</code></pre><p><strong>示例 2:</strong></p><pre><code class="java">输入: &quot;()[]&#123;&#125;&quot;输出: true</code></pre><p><strong>示例 3:</strong></p><pre><code class="java">输入: &quot;(]&quot;输出: false</code></pre><p><strong>示例 4:</strong></p><pre><code class="java">输入: &quot;([)]&quot;输出: false</code></pre><p><strong>示例 5:</strong></p><pre><code class="java">输入: &quot;&#123;[]&#125;&quot;输出: true</code></pre><p>通过次数435,296</p><p>提交次数1,008,971</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public boolean isValid(String s) &#123;        if(s.length() %2 !=0 ) return false;        LinkedList&lt;Character&gt; temp = new LinkedList&lt;&gt;();        for(char c : s.toCharArray())&#123;            if( c == &#39;(&#39;) temp.add(&#39;)&#39;);            else if( c== &#39;&#123;&#39;) temp.add(&#39;&#125;&#39;);            else if( c==&#39;[&#39;) temp.add(&#39;]&#39;);            else if( temp.isEmpty() ||  c != temp.pollLast()) return false;        &#125;        return temp.isEmpty();    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22. 括号生成</title>
      <link href="2020/10/17/22.%20%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"/>
      <url>2020/10/17/22.%20%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h4 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode-cn.com/problems/generate-parentheses/">22. 括号生成</a></h4><p>难度中等1371收藏分享切换为英文接收动态反馈</p><p>数字 <em>n</em> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><p><strong>示例：</strong></p><pre><code class="java">输入：n = 3输出：[       &quot;((()))&quot;,       &quot;(()())&quot;,       &quot;(())()&quot;,       &quot;()(())&quot;,       &quot;()()()&quot;     ]</code></pre><p>通过次数189,571</p><p>提交次数248,107</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public List&lt;String&gt; generateParenthesis(int n) &#123;        List&lt;String&gt; res = new ArrayList&lt;&gt;();        if(n ==0) return res;        traceBack(&quot;&quot;,0,0,n,res);        return res;    &#125;    void traceBack(String temp, int left, int right, int n, List&lt;String&gt; res)&#123;        if( left == n &amp;&amp; right ==n)&#123;            res.add(temp);            return;        &#125;        if( left &lt; right) return; //剪枝，是的左括号的个数严格大于右括号的个数，才剪枝        if(left &lt; n)&#123;            traceBack(temp + &quot;(&quot;, left + 1, right, n , res);        &#125;        if(right &lt; n)&#123;            traceBack(temp+ &quot;)&quot;, left, right+1, n, res);        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 回溯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>51. N 皇后</title>
      <link href="2020/10/17/51.%20N%20%E7%9A%87%E5%90%8E/"/>
      <url>2020/10/17/51.%20N%20%E7%9A%87%E5%90%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="51-N-皇后"><a href="#51-N-皇后" class="headerlink" title="51. N 皇后"></a><a href="https://leetcode-cn.com/problems/n-queens/">51. N 皇后</a></h1><p>难度困难637</p><p><em>n</em> 皇后问题研究的是如何将 <em>n</em> 个皇后放置在 <em>n</em>×<em>n</em> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/8-queens.png" alt="img"></p><p>上图为 8 皇后问题的一种解法。</p><p>给定一个整数 <em>n</em>，返回所有不同的 <em>n</em> 皇后问题的解决方案。</p><p>每一种解法包含一个明确的 <em>n</em> 皇后问题的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p><p><strong>示例：</strong></p><pre><code class="java">输入：4输出：[ [&quot;.Q..&quot;,  // 解法 1  &quot;...Q&quot;,  &quot;Q...&quot;,  &quot;..Q.&quot;], [&quot;..Q.&quot;,  // 解法 2  &quot;Q...&quot;,  &quot;...Q&quot;,  &quot;.Q..&quot;]]解释: 4 皇后问题存在两个不同的解法。</code></pre><p><strong>提示：</strong></p><ul><li>皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。</li></ul><p>通过次数82,902</p><p>提交次数113,295</p><p>在真实的面试中遇到过这道题？</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123;        //先构建棋盘        char[][] chess = new char[n][n];        for(int i = 0; i &lt;n; i++)&#123;            for(int j = 0; j &lt;n;j++)&#123;                chess[i][j] = &#39;.&#39;;            &#125;        &#125;        List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;();        traceBack( res, chess, 0);        return res;    &#125;    //回溯    void traceBack(List&lt;List&lt;String&gt;&gt; res, char[][] chess, int row)&#123;        if( row == chess.length)&#123;            res.add( construct(chess));            return;        &#125;        for(int col = 0; col &lt; chess.length; col++)&#123;            if( valid(chess, row, col))&#123;                chess[row][col] = &#39;Q&#39;;                traceBack(res, chess, row+1);                chess[row][col] = &#39;.&#39;;            &#125;        &#125;    &#125;    //row 表示行， col  表示列 valid函数表示当前的格子能否放入Q    boolean valid( char[][] chess, int row, int col)&#123;        //判断列有没有Q        for(int i = 0 ; i &lt; row ; i++)&#123;            if(chess[i][col] ==&#39;Q&#39;)&#123;                return false;            &#125;        &#125;        //判断右上角有没有Q        for(int i = row - 1, j = col +1 ; i &gt;= 0 &amp;&amp; j &lt; chess.length; i--, j++)&#123;            if(chess[i][j] ==&#39;Q&#39;)&#123;                return false;            &#125;        &#125;        //判断左上角有没有Q        for(int i = row - 1, j  = col -1; i&gt;= 0 &amp;&amp; j &gt;=0; i--, j--)&#123;            if(chess[i][j] ==&#39;Q&#39;)&#123;                return false;            &#125;        &#125;        return true;    &#125;    //把数组转为list    List&lt;String&gt; construct(char[][] chess)&#123;        List&lt;String&gt; temp = new ArrayList&lt;&gt;();        for(int i =0; i &lt; chess.length; i++)&#123;            temp.add(new String(chess[i]));        &#125;        return temp;    &#125;&#125;</code></pre><hr><p>参考:</p><p><a href="https://leetcode-cn.com/problems/n-queens/solution/nhuang-hou-jing-dian-hui-su-suan-fa-tu-wen-xiang-j/">N皇后，经典回溯算法（图文详解）</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 回溯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>491. 递增子序列</title>
      <link href="2020/10/17/491.%20%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>2020/10/17/491.%20%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="491-递增子序列"><a href="#491-递增子序列" class="headerlink" title="491. 递增子序列"></a><a href="https://leetcode-cn.com/problems/increasing-subsequences/">491. 递增子序列</a></h1><p>难度中等216收藏分享切换为英文接收动态反馈</p><p>给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。</p><p><strong>示例:</strong></p><pre><code class="java">输入: [4, 6, 7, 7]输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]</code></pre><p><strong>说明:</strong></p><ol><li>给定数组的长度不会超过15。</li><li>数组中的整数范围是 [-100,100]。</li><li>给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。</li></ol><p>通过次数29,313</p><p>提交次数52,378</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) &#123;        Set&lt;List&lt;Integer&gt;&gt; res = new HashSet&lt;&gt;();        if( nums == null || nums.length == 0)&#123;            return new ArrayList&lt;&gt;(res);        &#125;         traceBack(nums, 0, new LinkedList&lt;Integer&gt;(), res);        return new ArrayList&lt;&gt;(res);    &#125;    void traceBack(int[] nums, int start, LinkedList&lt;Integer&gt; temp, Set&lt;List&lt;Integer&gt;&gt; res)&#123;        if(temp.size() &gt; 1)&#123;            res.add(new LinkedList&lt;Integer&gt;(temp));        &#125;        for(int i =start; i &lt; nums.length; i++)&#123;            if(temp.size() &gt; nums.length) break;            //if( i &gt; start &amp;&amp; nums[i] ==nums[i-1]) continue;            if( temp.isEmpty() || temp.peekLast() &lt;= nums[i])&#123;                temp.add(nums[i]);                traceBack(nums, i+1, temp, res);                temp.pollLast();            &#125;         &#125;    &#125;&#125;</code></pre><p><code>if( i &gt; start &amp;&amp; nums[i] ==nums[i-1]) continue;</code> 这段也可以用作去重， 但是需要在<code>res.add(new LinkedList&lt;Integer&gt;(temp));</code> 后添加return , 否则只能去掉 相邻的2个重复数字，</p><p>例如 ：<code>1，1, 1 ,1 </code> 只能去掉 第2个<code>1</code> ,只能利用hashset进行去重处理。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 回溯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>40. 组合总和 II</title>
      <link href="2020/10/17/40.%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20II/"/>
      <url>2020/10/17/40.%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20II/</url>
      
        <content type="html"><![CDATA[<h1 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a href="https://leetcode-cn.com/problems/combination-sum-ii/">40. 组合总和 II</a></h1><p>难度中等424收藏分享切换为英文接收动态反馈</p><p>给定一个数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用一次。</p><p><strong>说明：</strong></p><ul><li>所有数字（包括目标数）都是正整数。</li><li>解集不能包含重复的组合。 </li></ul><p><strong>示例 1:</strong></p><pre><code>输入: candidates = [10,1,2,7,6,1,5], target = 8,所求解集为:[  [1, 7],  [1, 2, 5],  [2, 6],  [1, 1, 6]]</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: candidates = [2,5,2,1,2], target = 5,所求解集为:[  [1,2,2],  [5]]</code></pre><p>通过次数112,924</p><p>提交次数174,967</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123;        List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();        if(candidates == null || candidates.length ==0) return res;        Arrays.sort(candidates);        traceBack(candidates, 0, target, 0, new LinkedList&lt;Integer&gt;(), res);        return res;    &#125;    void traceBack(int[] candidates, int sum, int target, int start, LinkedList&lt;Integer&gt; temp, List&lt;List&lt;Integer&gt;&gt; res)&#123;        if( sum == target)&#123;            res.add( new LinkedList&lt;&gt;(temp));            return;        &#125;        for(int i =start; i &lt; candidates.length; i++)&#123;            if(sum &gt;target) break;            if( i &gt; start &amp;&amp; candidates[i] == candidates[i-1]) continue;            temp.add(candidates[i]);            sum+=candidates[i];            traceBack(candidates, sum, target, i+1, temp, res);            temp.pollLast();            sum-=candidates[i];        &#125;    &#125;&#125;</code></pre><hr><p>不考虑时间复杂度</p><p>利用 <code>contains()</code>来对结果进行判重</p><pre><code class="java">class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123;        List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();        if(candidates == null || candidates.length ==0) return res;        Arrays.sort(candidates);        traceBack(candidates, 0, target, 0, new LinkedList&lt;Integer&gt;(), res);        return res;    &#125;    void traceBack(int[] candidates, int sum, int target, int start, LinkedList&lt;Integer&gt; temp, List&lt;List&lt;Integer&gt;&gt; res)&#123;        if( sum == target &amp;&amp; !res.contains(temp))&#123;            res.add( new LinkedList&lt;&gt;(temp));            return;        &#125;        for(int i =start; i &lt; candidates.length; i++)&#123;            if(sum &gt;target) break;            temp.add(candidates[i]);            sum+=candidates[i];            traceBack(candidates, sum, target, i+1, temp, res);            temp.pollLast();            sum-=candidates[i];        &#125;    &#125;&#125;</code></pre><p>参考：</p><p><a href="https://leetcode-cn.com/problems/combination-sum-ii/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-3/">回溯算法 + 剪枝（Java、Python）</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 回溯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>39. 组合总和</title>
      <link href="2020/10/17/39.%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/"/>
      <url>2020/10/17/39.%20%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h4 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a></h4><p>难度中等1001收藏分享切换为英文接收动态反馈</p><p>给定一个<strong>无重复元素</strong>的数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的数字可以无限制重复被选取。</p><p><strong>说明：</strong></p><ul><li>所有数字（包括 <code>target</code>）都是正整数。</li><li>解集不能包含重复的组合。 </li></ul><p><strong>示例 1：</strong></p><pre><code class="java">输入：candidates = [2,3,6,7], target = 7,所求解集为：[  [7],  [2,2,3]]</code></pre><p><strong>示例 2：</strong></p><pre><code class="java">输入：candidates = [2,3,5], target = 8,所求解集为：[  [2,2,2,2],  [2,3,3],  [3,5]]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 30</code></li><li><code>1 &lt;= candidates[i] &lt;= 200</code></li><li><code>candidate</code> 中的每个元素都是独一无二的。</li><li><code>1 &lt;= target &lt;= 500</code></li></ul><p>通过次数172,408</p><p>提交次数241,129</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;        List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();        if( candidates == null || candidates.length ==0) return res;        Arrays.sort(candidates); // 排序是减枝的基础        traceBack(  candidates,  new LinkedList&lt;Integer&gt;(), 0, 0, target, res);        return res;    &#125;    void traceBack(int[] candidates,LinkedList&lt;Integer&gt; temp ,int sum ,int start, int target,List&lt;List&lt;Integer&gt;&gt; res)&#123;        if(sum == target)&#123;            res.add( new LinkedList&lt;&gt;(temp));            return;        &#125;        for(int i = start; i &lt; candidates.length; i++)&#123;            if(sum &gt; target) break; //如果 sum &gt; target 则后面的都不需要继续 循环了 ，直接退出            temp.add(candidates[i]);            sum+= candidates[i];            traceBack( candidates, temp, sum ,  i, target, res);            temp.pollLast();            sum-=candidates[i];        &#125;    &#125;&#125;</code></pre><hr><blockquote><p>排列问题，讲究顺序（即 [2, 2, 3] 与 [2, 3, 2] 视为不同列表时），需要记录哪些数字已经使用过，此时用 used 数组；<br>组合问题，不讲究顺序（即 [2, 2, 3] 与 [2, 3, 2] 视为相同列表时），需要按照某种顺序搜索，此时使用 begin 变量。</p><p>作者：cherry-n1<br>链接：<a href="https://leetcode-cn.com/problems/combination-sum/solution/zu-he-zong-he-hui-su-jian-zhi-wu-jian-zhi-by-cherr/">https://leetcode-cn.com/problems/combination-sum/solution/zu-he-zong-he-hui-su-jian-zhi-wu-jian-zhi-by-cherr/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 回溯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>47. 全排列 II</title>
      <link href="2020/10/16/47.%20%E5%85%A8%E6%8E%92%E5%88%97%20II/"/>
      <url>2020/10/16/47.%20%E5%85%A8%E6%8E%92%E5%88%97%20II/</url>
      
        <content type="html"><![CDATA[<h1 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a><a href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a></h1><p>难度中等493收藏分享切换为英文接收动态反馈</p><p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p><p><strong>示例:</strong></p><pre><code class="java">输入: [1,1,2]输出:[  [1,1,2],  [1,2,1],  [2,1,1]]</code></pre><p>通过次数115,255</p><p>提交次数185,765</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123;        Arrays.sort(nums);        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();        boolean[] used = new boolean[nums.length];        traceBack(nums, new LinkedList&lt;Integer&gt;(), used,res);        return res;    &#125;    void traceBack(int[] nums, LinkedList&lt;Integer&gt; temp, boolean[] used, List&lt;List&lt;Integer&gt;&gt; res)&#123;        if( temp.size() == nums.length)&#123;            res.add(new LinkedList&lt;&gt;(temp));            return;        &#125;        for(int i =0; i &lt; nums.length; i++)&#123;            //used[i] == true 被选择的过的数不用再放进去了            //接下来，如果当前节点和他之前的节点一样， 并且他的前一个节点已经被遍历过了， 也不需要了            if( used[i] == true || ( i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; !used[i-1]))&#123;                continue;            &#125;            temp.add(nums[i]);            used[i] = true;            traceBack( nums, temp, used , res);            temp.pollLast();            used[i] = false;        &#125;    &#125;&#125;</code></pre><p>加上(i&gt;0 &amp;&amp; nums[i]==nums[i-1] &amp;&amp; !used[i-1])，注意：若used[i-1]==false表示在同一层前一个相同的数已被访问过然后又被撤销（撤销就是used[i]又被置为false）。实际上这里判断写!used[i-1]或者used[i-1]都可以，!used[i-1]是回溯树同一层剪枝（水平），used[i-1]是回溯数同一条剪枝（竖直），但是同一层剪枝效率更高。</p><h2 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h2><pre><code class="java">LinkedList result = new LinkedList();public void backtrack(路径，选择列表)&#123;    if(满足结束条件)&#123;        result.add(结果);    &#125;    for(选择：选择列表)&#123;        做出选择;        backtrack(路径，选择列表);        撤销选择;    &#125;&#125;</code></pre><p>  全排列，没有重复</p><pre><code class="java">class Solution &#123;    //回溯算法:不合适就退回上一步    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;        List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); //全局list用于存储最后的全排列结果        int len = nums.length;        //特判        if(len==0)  return list;        boolean[] used = new boolean[len]; //默认全为false，表示节点是否访问过（是：true,否：false)        List&lt;Integer&gt; path = new ArrayList&lt;&gt;();//存储全排列路径        dfs(nums,0,len,used,path,list);        return list;    &#125;    public void dfs(int[] nums, int depth, int len, boolean[] used,List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; list)&#123; //depth用来表示当前的状态在第几层，当depth==len表示一条完整的排列已经找到了        if(depth==len)&#123;            list.add(new ArrayList&lt;Integer&gt;(path));            return;        &#125;        // 在非叶子结点处产生不同的分支，这一操作的语义是：在还未选择的数中依次选择一个元素作为下一个位置的元素，通过一个循环实现        for(int i=0; i&lt;len; i++)&#123;            if(used[i]) continue;            path.add(nums[i]);            used[i] = true;            dfs(nums,depth+1,len,used,path,list);            // 注意：下面这两行代码发生「回溯」，回溯发生在从 深层结点 回到 浅层结点 的过程，代码在形式上和递归之前是对称的            used[i] = false;            path.remove(path.size()-1);        &#125;    &#125;&#125;作者：cherry-n1链接：https://leetcode-cn.com/problems/permutations-ii/solution/quan-pai-lie-i-quan-pai-lie-ii-hui-su-fa-javadai-m/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 回溯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>90. 子集 II</title>
      <link href="2020/10/16/90.%20%E5%AD%90%E9%9B%86%20II/"/>
      <url>2020/10/16/90.%20%E5%AD%90%E9%9B%86%20II/</url>
      
        <content type="html"><![CDATA[<h4 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a><a href="https://leetcode-cn.com/problems/subsets-ii/">90. 子集 II</a></h4><p>难度中等326</p><p>给定一个可能包含重复元素的整数数组 <strong><em>nums</em></strong>，返回该数组所有可能的子集（幂集）。</p><p><strong>说明：</strong>解集不能包含重复的子集。</p><p><strong>示例:</strong></p><pre><code class="java">输入: [1,2,2]输出:[  [2],  [1],  [1,2,2],  [2,2],  [1,2],  []]</code></pre><p>通过次数53,253</p><p>提交次数86,972</p><p>在真实的面试中遇到过这道题？</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123;        //排序后保证相邻的是重复元素        Arrays.sort(nums);        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();        trackBack(nums, 0, new LinkedList&lt;Integer&gt;(), res);        return res;    &#125;    void trackBack(int[] nums, int start, LinkedList&lt;Integer&gt; temp , List&lt;List&lt;Integer&gt;&gt; res)&#123;        res.add(new LinkedList&lt;&gt;(temp));        for(int i=start; i &lt; nums.length; i++)&#123;            if( i &gt; start &amp;&amp; nums[i] == nums[i-1])&#123; // i&gt; start 是为了保证从start+1开始                continue;            &#125;            temp.add(nums[i]);            trackBack(nums,i+1,temp,res);            temp.pollLast();        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 回溯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>78. 子集</title>
      <link href="2020/10/16/78.%20%E5%AD%90%E9%9B%86/"/>
      <url>2020/10/16/78.%20%E5%AD%90%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h4 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a href="https://leetcode-cn.com/problems/subsets/">78. 子集</a></h4><p>难度中等842</p><p>给定一组<strong>不含重复元素</strong>的整数数组 <em>nums</em>，返回该数组所有可能的子集（幂集）。</p><p><strong>说明：</strong>解集不能包含重复的子集。</p><p><strong>示例:</strong></p><pre><code class="java">输入: nums = [1,2,3]输出:[  [3],  [1],  [2],  [1,2,3],  [1,3],  [2,3],  [1,2],  []]</code></pre><p>通过次数161,791</p><p>提交次数204,475</p><p>在真实的面试中遇到过这道题？</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;        List&lt;List&lt;Integer&gt;&gt;  res = new ArrayList&lt;&gt;();        traceBack( nums,0, new ArrayList&lt;Integer&gt;(), res);        return res;    &#125;    private void traceBack(int[] nums,int start, ArrayList&lt;Integer&gt; temp, List&lt;List&lt;Integer&gt;&gt; res)&#123;        res.add( new ArrayList&lt;&gt;(temp));        for(int i = start; i &lt; nums.length; i++)&#123;            temp.add(nums[i]);            traceBack(nums, i+1, temp, res);            temp.remove(temp.size()-1);        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 回溯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>875. 爱吃香蕉的珂珂</title>
      <link href="2020/10/14/875.%20%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82/"/>
      <url>2020/10/14/875.%20%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82/</url>
      
        <content type="html"><![CDATA[<h4 id="875-爱吃香蕉的珂珂"><a href="#875-爱吃香蕉的珂珂" class="headerlink" title="875. 爱吃香蕉的珂珂"></a><a href="https://leetcode-cn.com/problems/koko-eating-bananas/">875. 爱吃香蕉的珂珂</a></h4><p>难度中等108</p><p>珂珂喜欢吃香蕉。这里有 <code>N</code> 堆香蕉，第 <code>i</code> 堆中有 <code>piles[i]</code> 根香蕉。警卫已经离开了，将在 <code>H</code> 小时后回来。</p><p>珂珂可以决定她吃香蕉的速度 <code>K</code> （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 <code>K</code> 根。如果这堆香蕉少于 <code>K</code> 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。 </p><p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p><p>返回她可以在 <code>H</code> 小时内吃掉所有香蕉的最小速度 <code>K</code>（<code>K</code> 为整数）。</p><p><strong>示例 1：</strong></p><pre><code class="java">输入: piles = [3,6,7,11], H = 8输出: 4</code></pre><p><strong>示例 2：</strong></p><pre><code class="java">输入: piles = [30,11,23,4,20], H = 5输出: 30</code></pre><p><strong>示例 3：</strong></p><pre><code class="java">输入: piles = [30,11,23,4,20], H = 6输出: 23</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= piles.length &lt;= 10^4</code></li><li><code>piles.length &lt;= H &lt;= 10^9</code></li><li><code>1 &lt;= piles[i] &lt;= 10^9</code></li></ul><p>通过次数19,912</p><p>提交次数44,312</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public int minEatingSpeed(int[] piles, int H) &#123;        int l = 1;        int r = 1;        for(int i : piles)&#123;            r = Math.max(r,i);        &#125;        while(l &lt; r)&#123;            int mid = l + (r-l)/2;            if(check(piles, H, mid))&#123;                r = mid;            &#125;else&#123;                l = mid+1;            &#125;        &#125;        return l;    &#125;    private boolean check(int[] piles, int H , int mid)&#123;        int sum = 0;        for(int i : piles)&#123;            if( i &lt;= mid)&#123;                sum++;            &#125;else&#123;                sum+=(i/mid)+1;            &#125;        &#125;        return sum &lt;= H;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二分搜索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 二分搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1011. 在 D 天内送达包裹的能力</title>
      <link href="2020/10/14/1011.%20%E5%9C%A8%20D%20%E5%A4%A9%E5%86%85%E9%80%81%E8%BE%BE%E5%8C%85%E8%A3%B9%E7%9A%84%E8%83%BD%E5%8A%9B/"/>
      <url>2020/10/14/1011.%20%E5%9C%A8%20D%20%E5%A4%A9%E5%86%85%E9%80%81%E8%BE%BE%E5%8C%85%E8%A3%B9%E7%9A%84%E8%83%BD%E5%8A%9B/</url>
      
        <content type="html"><![CDATA[<h4 id="1011-在-D-天内送达包裹的能力"><a href="#1011-在-D-天内送达包裹的能力" class="headerlink" title="1011. 在 D 天内送达包裹的能力"></a><a href="https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/">1011. 在 D 天内送达包裹的能力</a></h4><p>难度中等134</p><p>传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。</p><p>传送带上的第 <code>i</code> 个包裹的重量为 <code>weights[i]</code>。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。</p><p>返回能在 <code>D</code> 天内将传送带上的所有包裹送达的船的最低运载能力。</p><p><strong>示例 1：</strong></p><pre><code class="java">输入：weights = [1,2,3,4,5,6,7,8,9,10], D = 5输出：15解释：船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：第 1 天：1, 2, 3, 4, 5第 2 天：6, 7第 3 天：8第 4 天：9第 5 天：10请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。 </code></pre><p><strong>示例 2：</strong></p><pre><code class="java">输入：weights = [3,2,2,4,1,4], D = 3输出：6解释：船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示：第 1 天：3, 2第 2 天：2, 4第 3 天：1, 4</code></pre><p><strong>示例 3：</strong></p><pre><code class="java">输入：weights = [1,2,3,1,1], D = 4输出：3解释：第 1 天：1第 2 天：2第 3 天：3第 4 天：1, 1</code></pre><p><strong>提示：</strong></p><ol><li><code>1 &lt;= D &lt;= weights.length &lt;= 50000</code></li><li><code>1 &lt;= weights[i] &lt;= 500</code></li></ol><p>通过次数11,902</p><p>提交次数21,902</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public int shipWithinDays(int[] weights, int D) &#123;        int l = 0;        int r = 0;        for(int i =0; i &lt; weights.length; i++)&#123;            l = Math.max(l, weights[i]);            r+= weights[i];        &#125;        while( l &lt; r)&#123;            int mid = l + (r-l)/2;            if( check(weights, D, mid))&#123;                r = mid;            &#125;else&#123;                l = mid+1;            &#125;        &#125;        return l;    &#125;    private boolean check(int[] weights, int D, int mid)&#123;        int temp = mid;        for(int i : weights)&#123;            //如果当前i的重量超过 当前的运送能力，那么只能等下一天再运，也就是运送能力重置， 天数-1            if(i&gt;temp)&#123;                temp = mid;                D--;            &#125;            temp-=i;        &#125;        return D&gt;0;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二分搜索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 二分搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>287. 寻找重复数</title>
      <link href="2020/10/13/287.%20%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/"/>
      <url>2020/10/13/287.%20%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/">287. 寻找重复数</a></h4><p>难度中等907</p><p>给定一个包含 <em>n</em> + 1 个整数的数组 <em>nums</em>，其数字都在 1 到 <em>n</em> 之间（包括 1 和 <em>n</em>），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p><p><strong>示例 1:</strong></p><pre><code class="java">输入: [1,3,4,2,2]输出: 2</code></pre><p><strong>示例 2:</strong></p><pre><code class="java">输入: [3,1,3,4,2]输出: 3</code></pre><p><strong>说明：</strong></p><ol><li><strong>不能</strong>更改原数组（假设数组是只读的）。</li><li>只能使用额外的 <em>O</em>(1) 的空间。</li><li>时间复杂度小于 <em>O</em>(<em>n</em>2) 。</li><li>数组中只有一个重复的数字，但它可能不止重复出现一次。</li></ol><p>通过次数101,723</p><p>提交次数154,276</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public int findDuplicate(int[] nums) &#123;        Set&lt;Integer&gt; temp = new HashSet&lt;&gt;();        int res = 0;        for(int i =0; i &lt; nums.length; i++)&#123;            temp.add( nums[i]);            if(temp.size() != i+1)&#123;                res= nums[i];                break;            &#125;        &#125;        return res;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>46. 全排列</title>
      <link href="2020/10/09/46.%20%E5%85%A8%E6%8E%92%E5%88%97/"/>
      <url>2020/10/09/46.%20%E5%85%A8%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></h1><p>难度中等939收藏分享切换为英文接收动态反馈</p><p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p><p><strong>示例:</strong></p><pre><code class="java">输入: [1,2,3]输出:[  [1,2,3],  [1,3,2],  [2,1,3],  [2,3,1],  [3,1,2],  [3,2,1]]</code></pre><p>通过次数204,324</p><p>提交次数265,348</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;        List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();        traceBack(nums, new LinkedList&lt;Integer&gt;(), res);        return res;    &#125;    public void traceBack(int[] nums,  LinkedList&lt;Integer&gt; temp,List&lt;List&lt;Integer&gt;&gt; res)&#123;        if( temp.size() == nums.length)&#123;            res.add( new LinkedList(temp)); //如果长度为nums.length 就添加            return;        &#125;        for(int i =0; i &lt; nums.length ; i++)&#123;            if( temp.contains(nums[i]))&#123;                continue;            &#125;            temp.add(nums[i]); //将当前元素加入            traceBack( nums,temp, res);  // 继续向后继续添加            temp.pollLast(); // 将刚添加的元素去除掉， 尝试新的元素        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 回溯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1550. 存在连续三个奇数的数组</title>
      <link href="2020/10/09/1550.%20%E5%AD%98%E5%9C%A8%E8%BF%9E%E7%BB%AD%E4%B8%89%E4%B8%AA%E5%A5%87%E6%95%B0%E7%9A%84%E6%95%B0%E7%BB%84/"/>
      <url>2020/10/09/1550.%20%E5%AD%98%E5%9C%A8%E8%BF%9E%E7%BB%AD%E4%B8%89%E4%B8%AA%E5%A5%87%E6%95%B0%E7%9A%84%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="1550-存在连续三个奇数的数组"><a href="#1550-存在连续三个奇数的数组" class="headerlink" title="1550. 存在连续三个奇数的数组"></a><a href="https://leetcode-cn.com/problems/three-consecutive-odds/">1550. 存在连续三个奇数的数组</a></h1><p>难度简单5收藏分享切换为英文接收动态反馈</p><p>给你一个整数数组 <code>arr</code>，请你判断数组中是否存在连续三个元素都是奇数的情况：如果存在，请返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><pre><code class="java">输入：arr = [2,6,4,1]输出：false解释：不存在连续三个元素都是奇数的情况。</code></pre><p><strong>示例 2：</strong></p><pre><code class="java">输入：arr = [1,2,34,3,4,5,7,23,12]输出：true解释：存在连续三个元素都是奇数的情况，即 [5,7,23] 。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 1000</code></li><li><code>1 &lt;= arr[i] &lt;= 1000</code></li></ul><p>通过次数9,836</p><p>提交次数14,174</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public boolean threeConsecutiveOdds(int[] arr) &#123;        List&lt;Integer&gt; res = new LinkedList&lt;&gt;();        for(int i =0; i &lt; arr.length; i++)&#123;            if( isOdds( arr[i]))&#123;                res.add(arr[i]);                &#125;else&#123;                res.clear();            &#125;            if( res.size() == 3) return true;        &#125;        return false;    &#125;    boolean isOdds(int i)&#123;        if(i%2 == 1) return true;        else return false;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1528. 重新排列字符串</title>
      <link href="2020/10/09/1528.%20%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>2020/10/09/1528.%20%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="1528-重新排列字符串"><a href="#1528-重新排列字符串" class="headerlink" title="1528. 重新排列字符串"></a><a href="https://leetcode-cn.com/problems/shuffle-string/">1528. 重新排列字符串</a></h1><p>难度简单17收藏分享切换为英文接收动态反馈</p><p>给你一个字符串 <code>s</code> 和一个 <strong>长度相同</strong> 的整数数组 <code>indices</code> 。</p><p>请你重新排列字符串 <code>s</code> ，其中第 <code>i</code> 个字符需要移动到 <code>indices[i]</code> 指示的位置。</p><p>返回重新排列后的字符串。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/26/q1.jpg" alt="img"></p><pre><code class="java">输入：s = &quot;codeleet&quot;, indices = [4,5,6,7,0,2,1,3]输出：&quot;leetcode&quot;解释：如图所示，&quot;codeleet&quot; 重新排列后变为 &quot;leetcode&quot; 。</code></pre><p><strong>示例 2：</strong></p><pre><code class="java">输入：s = &quot;abc&quot;, indices = [0,1,2]输出：&quot;abc&quot;解释：重新排列后，每个字符都还留在原来的位置上。</code></pre><p><strong>示例 3：</strong></p><pre><code class="java">输入：s = &quot;aiohn&quot;, indices = [3,1,4,2,0]输出：&quot;nihao&quot;</code></pre><p><strong>示例 4：</strong></p><pre><code class="java">输入：s = &quot;aaiougrt&quot;, indices = [4,0,2,6,7,3,1,5]输出：&quot;arigatou&quot;</code></pre><p><strong>示例 5：</strong></p><pre><code class="java">输入：s = &quot;art&quot;, indices = [1,0,2]输出：&quot;rat&quot;</code></pre><p><strong>提示：</strong></p><ul><li><code>s.length == indices.length == n</code></li><li><code>1 &lt;= n &lt;= 100</code></li><li><code>s</code> 仅包含小写英文字母。</li><li><code>0 &lt;= indices[i] &lt; n</code></li><li><code>indices</code> 的所有的值都是唯一的（也就是说，<code>indices</code> 是整数 <code>0</code> 到 <code>n - 1</code> 形成的一组排列）。</li></ul><p>通过次数14,471</p><p>提交次数18,245</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public String restoreString(String s, int[] indices) &#123;        HashMap&lt;Integer, Character&gt; m = new HashMap&lt;&gt;();        for( int i = 0; i &lt; indices.length ; i++)&#123;            m.put(indices[i], s.charAt(i));        &#125;        char[] res = new char[s.length()];        for( int i =0 ; i &lt; indices.length; i++)&#123;            res[i] = m.get(i);        &#125;        return String.valueOf(res);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> hash </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1539. 第 k 个缺失的正整数</title>
      <link href="2020/10/09/1539.%20%E7%AC%AC%20k%20%E4%B8%AA%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%AD%A3%E6%95%B4%E6%95%B0/"/>
      <url>2020/10/09/1539.%20%E7%AC%AC%20k%20%E4%B8%AA%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%AD%A3%E6%95%B4%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1539-第-k-个缺失的正整数"><a href="#1539-第-k-个缺失的正整数" class="headerlink" title="1539. 第 k 个缺失的正整数"></a><a href="https://leetcode-cn.com/problems/kth-missing-positive-number/">1539. 第 k 个缺失的正整数</a></h1><p>难度简单9收藏分享切换为英文接收动态反馈</p><p>给你一个 <strong>严格升序排列</strong> 的正整数数组 <code>arr</code> 和一个整数 <code>k</code> 。</p><p>请你找到这个数组里第 <code>k</code> 个缺失的正整数。</p><p><strong>示例 1：</strong></p><pre><code class="java">输入：arr = [2,3,4,7,11], k = 5输出：9解释：缺失的正整数包括 [1,5,6,8,9,10,12,13,...] 。第 5 个缺失的正整数为 9 。</code></pre><p><strong>示例 2：</strong></p><pre><code class="java">输入：arr = [1,2,3,4], k = 2输出：6解释：缺失的正整数包括 [5,6,7,...] 。第 2 个缺失的正整数为 6 。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 1000</code></li><li><code>1 &lt;= arr[i] &lt;= 1000</code></li><li><code>1 &lt;= k &lt;= 1000</code></li><li>对于所有 <code>1 &lt;= i &lt; j &lt;= arr.length</code> 的 <code>i</code> 和 <code>j</code> 满足 <code>arr[i] &lt; arr[j]</code> </li></ul><p>通过次数5,491</p><p>提交次数10,218</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public int findKthPositive(int[] arr, int k) &#123;        int n = 1;        int res = 0;        for(int i : arr)&#123;            while( i != n)&#123;                res++;                n++;                if(res == k) return n-1;            &#125;            n++;        &#125;        while(res &lt; k)&#123;            res++;            n++;        &#125;        return n-1;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1170. 比较字符串最小字母出现频次</title>
      <link href="2020/09/29/1170.%20%E6%AF%94%E8%BE%83%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%80%E5%B0%8F%E5%AD%97%E6%AF%8D%E5%87%BA%E7%8E%B0%E9%A2%91%E6%AC%A1/"/>
      <url>2020/09/29/1170.%20%E6%AF%94%E8%BE%83%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%80%E5%B0%8F%E5%AD%97%E6%AF%8D%E5%87%BA%E7%8E%B0%E9%A2%91%E6%AC%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="1170-比较字符串最小字母出现频次"><a href="#1170-比较字符串最小字母出现频次" class="headerlink" title="1170. 比较字符串最小字母出现频次"></a><a href="https://leetcode-cn.com/problems/compare-strings-by-frequency-of-the-smallest-character/">1170. 比较字符串最小字母出现频次</a></h1><p>难度简单29</p><p>我们来定义一个函数 <code>f(s)</code>，其中传入参数 <code>s</code> 是一个非空字符串；该函数的功能是统计 <code>s</code> 中（按字典序比较）最小字母的出现频次。</p><p>例如，若 <code>s = &quot;dcce&quot;</code>，那么 <code>f(s) = 2</code>，因为最小的字母是 <code>&quot;c&quot;</code>，它出现了 2 次。</p><p>现在，给你两个字符串数组待查表 <code>queries</code> 和词汇表 <code>words</code>，请你返回一个整数数组 <code>answer</code> 作为答案，其中每个 <code>answer[i]</code> 是满足 <code>f(queries[i])</code> &lt; <code>f(W)</code> 的词的数目，<code>W</code> 是词汇表 <code>words</code> 中的词。</p><p><strong>示例 1：</strong></p><pre><code class="java">输入：queries = [&quot;cbd&quot;], words = [&quot;zaaaz&quot;]输出：[1]解释：查询 f(&quot;cbd&quot;) = 1，而 f(&quot;zaaaz&quot;) = 3 所以 f(&quot;cbd&quot;) &lt; f(&quot;zaaaz&quot;)。</code></pre><p><strong>示例 2：</strong></p><pre><code class="java">输入：queries = [&quot;bbb&quot;,&quot;cc&quot;], words = [&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;]输出：[1,2]解释：第一个查询 f(&quot;bbb&quot;) &lt; f(&quot;aaaa&quot;)，第二个查询 f(&quot;aaa&quot;) 和 f(&quot;aaaa&quot;) 都 &gt; f(&quot;cc&quot;)。</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= queries.length &lt;= 2000</code></li><li><code>1 &lt;= words.length &lt;= 2000</code></li><li><code>1 &lt;= queries[i].length, words[i].length &lt;= 10</code></li><li><code>queries[i][j]</code>, <code>words[i][j]</code> 都是小写英文字母</li></ul><p>通过次数9,378</p><p>提交次数15,450</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public int[] numSmallerByFrequency(String[] queries, String[] words) &#123;        int[] wordsCount = new int[words.length];        int[] res = new int[queries.length];        for(int i = 0; i &lt; words.length; i++)&#123;            wordsCount[i] = f(words[i]);        &#125;         for(int i =0; i &lt; queries.length; i++)&#123;            for(int j =0; j &lt; wordsCount.length ;j++)&#123;                if(f(queries[i]) &lt;wordsCount[j] )&#123;                    res[i]++;                &#125;            &#125;        &#125;        return res;    &#125;    public static int f(String s)&#123;        if(s.length() ==1) return 1;        int count = 1;        char minChar = s.charAt(0);        for(int i =1 ; i &lt; s.length() ;i++ )&#123;            if( minChar &gt; s.charAt(i))&#123;                count = 1;                minChar = s.charAt(i);                continue;            &#125;            if( minChar == s.charAt(i))&#123;                count++;            &#125;        &#125;        return count;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 二分搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>74. 搜索二维矩阵</title>
      <link href="2020/09/26/74.%20%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/"/>
      <url>2020/09/26/74.%20%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="74-搜索二维矩阵"><a href="#74-搜索二维矩阵" class="headerlink" title="74. 搜索二维矩阵"></a><a href="https://leetcode-cn.com/problems/search-a-2d-matrix/">74. 搜索二维矩阵</a></h1><p>难度中等249</p><p>编写一个高效的算法来判断 <em>m</em> x <em>n</em> 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p><ul><li>每行中的整数从左到右按升序排列。</li><li>每行的第一个整数大于前一行的最后一个整数。</li></ul><p><strong>示例 1:</strong></p><pre><code class="java">输入:matrix = [  [1,   3,  5,  7],  [10, 11, 16, 20],  [23, 30, 34, 50]]target = 3输出: true</code></pre><p><strong>示例 2:</strong></p><pre><code class="java">输入:matrix = [  [1,   3,  5,  7],  [10, 11, 16, 20],  [23, 30, 34, 50]]target = 13输出: false</code></pre><p>通过次数63,695</p><p>提交次数163,381</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public boolean searchMatrix(int[][] matrix, int target) &#123;        if (matrix.length == 0) &#123;            return false;        &#125;        if (matrix[0].length == 0) &#123;            return false;        &#125;        if (matrix[0][0] == target) &#123;            return true;        &#125;        int row = matrix.length;;        int col = matrix[0].length;        if( target &lt; matrix[0][0] || target &gt; matrix[row-1][col-1]) return false;        //查找行        List&lt;Integer&gt; row_temp = new ArrayList&lt;&gt;();        for(int i =0; i &lt; row; i++)&#123;            row_temp.add(matrix[i][0]);        &#125;        int l = 0;        int r = row_temp.size();        while( l &lt; r)&#123;            int mid = l + ( r - l)/2;            if(row_temp.get(mid) == target) return true;            else if( row_temp.get(mid) &gt; target)&#123;                r--;            &#125;else&#123;                l++;            &#125;        &#125;        //查找列        List&lt;Integer&gt; col_temp = new ArrayList&lt;&gt;();        for(int i = 0; i &lt; col; i++)&#123;            col_temp.add(matrix[l-1][i]);        &#125;        int col_l = 0;        int col_r = col_temp.size();        while( col_l &lt; col_r)&#123;            int col_mid = col_l + (col_r - col_l)/2;            if( target == col_temp.get(col_mid))&#123;                return true;            &#125;            else if(col_temp.get(col_mid) &lt; target  )&#123;                col_l = col_mid+1;            &#125;else&#123;                col_r = col_mid;            &#125;        &#125;        return false;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 矩阵 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 二分搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18. 四数之和</title>
      <link href="2020/09/26/18.%20%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>2020/09/26/18.%20%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode-cn.com/problems/4sum/">18. 四数之和</a></h1><p>难度中等572收藏分享切换为英文关注反馈</p><p>给定一个包含 <em>n</em> 个整数的数组 <code>nums</code> 和一个目标值 <code>target</code>，判断 <code>nums</code> 中是否存在四个元素 <em>a，**b，c</em> 和 <em>d</em> ，使得 <em>a</em> + <em>b</em> + <em>c</em> + <em>d</em> 的值与 <code>target</code> 相等？找出所有满足条件且不重复的四元组。</p><p><strong>注意：</strong></p><p>答案中不可以包含重复的四元组。</p><p><strong>示例：</strong></p><pre><code>给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。满足要求的四元组集合为：[  [-1,  0, 0, 1],  [-2, -1, 1, 2],  [-2,  0, 0, 2]]</code></pre><p>通过次数109,330</p><p>提交次数284,514</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;        Arrays.sort(nums);        Set&lt;List&lt;Integer&gt;&gt; list = new HashSet&lt;&gt;();        for(int i =0; i &lt; nums.length; i++)&#123;            for(int j = i+1; j &lt; nums.length;j++)&#123;                int l = j+1;                int r = nums.length-1;                while( l &lt; r)&#123;                    int temp = nums[i] + nums[j] + nums[l] + nums[r];                    if(temp &lt; target)&#123;                        l++;                    &#125;else if( temp &gt; target)&#123;                        r--;                    &#125;else&#123;                        list.add( Arrays.asList( new Integer[]&#123; nums[i], nums[j], nums[l] , nums[r]&#125;));                        l++;                        r--;                    &#125;                &#125;            &#125;        &#125;        return new ArrayList&lt;&gt;(list);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 二分搜索 </tag>
            
            <tag> hash </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13. 罗马数字转整数</title>
      <link href="2020/09/24/13.%20%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
      <url>2020/09/24/13.%20%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a><a href="https://leetcode-cn.com/problems/roman-to-integer/">13. 罗马数字转整数</a></h1><p>难度简单1051</p><p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p><pre><code class="java">字符          数值I             1V             5X             10L             50C             100D             500M             1000</code></pre><p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做 <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><ul><li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li><li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li><li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><p><strong>示例 1:</strong></p><pre><code class="java">输入: &quot;III&quot;输出: 3</code></pre><p><strong>示例 2:</strong></p><pre><code class="java">输入: &quot;IV&quot;输出: 4</code></pre><p><strong>示例 3:</strong></p><pre><code class="java">输入: &quot;IX&quot;输出: 9</code></pre><p><strong>示例 4:</strong></p><pre><code class="java">输入: &quot;LVIII&quot;输出: 58解释: L = 50, V= 5, III = 3.</code></pre><p><strong>示例 5:</strong></p><pre><code class="java">输入: &quot;MCMXCIV&quot;输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4.</code></pre><p><strong>提示：</strong></p><ul><li>题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。</li><li>IC 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。</li><li>关于罗马数字的详尽书写规则，可以参考 <a href="https://b2b.partcommunity.com/community/knowledge/zh_CN/detail/10753/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97#knowledge_article">罗马数字 - Mathematics </a>。</li></ul><p>通过次数260,364</p><p>提交次数419,352</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public int romanToInt(String s) &#123;        HashMap&lt;Character, Integer&gt; m = new HashMap&lt;&gt;();        m.put(&#39;I&#39;,1);        m.put(&#39;V&#39;,5);        m.put(&#39;X&#39;,10);        m.put(&#39;L&#39;,50);        m.put(&#39;C&#39;,100);        m.put(&#39;D&#39;,500);        m.put(&#39;M&#39;,1000);        int res = m.get( s.charAt( s.length()-1));        for(int i = s.length()-2; i&gt;=0;i--)&#123;            if( m.get( s.charAt(i)) &lt; m.get( s.charAt(i+1)))&#123;                res -= m.get( s.charAt(i));            &#125;else&#123;                res += m.get( s.charAt(i));            &#125;        &#125;        return res;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>448. 找到所有数组中消失的数字</title>
      <link href="2020/09/24/448.%20%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>2020/09/24/448.%20%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h4 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="448. 找到所有数组中消失的数字"></a><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/">448. 找到所有数组中消失的数字</a></h4><p>难度简单462收藏分享切换为英文关注反馈</p><p>给定一个范围在 1 ≤ a[i] ≤ <em>n</em> ( <em>n</em> = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p><p>找到所有在 [1, <em>n</em>] 范围之间没有出现在数组中的数字。</p><p>您能在不使用额外空间且时间复杂度为*O(n)*的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p><p><strong>示例:</strong></p><pre><code class="java">输入:[4,3,2,7,8,2,3,1]输出:[5,6]</code></pre><p>通过次数55,420</p><p>提交次数92,080</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123;        HashMap&lt;Integer,Integer&gt; m = new HashMap&lt;&gt;();        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();        for(int i : nums)&#123;            m.put( i,0);        &#125;        for(int i = 1 ; i &lt; nums.length+1 ;i++)&#123;            if(! m.containsKey(i))&#123;                res.add(i);            &#125;        &#125;        return res;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>34. 在排序数组中查找元素的第一个和最后一个位置</title>
      <link href="2020/09/23/34.%20%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/"/>
      <url>2020/09/23/34.%20%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h1><p>难度中等597收藏分享切换为英文关注反馈</p><p>给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。</p><p>你的算法时间复杂度必须是 <em>O</em>(log <em>n</em>) 级别。</p><p>如果数组中不存在目标值，返回 <code>[-1, -1]</code>。</p><p><strong>示例 1:</strong></p><pre><code class="java">输入: nums = [5,7,7,8,8,10], target = 8输出: [3,4]</code></pre><p><strong>示例 2:</strong></p><pre><code class="java">输入: nums = [5,7,7,8,8,10], target = 6输出: [-1,-1]</code></pre><p>通过次数134,913</p><p>提交次数334,126</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public int[] searchRange(int[] nums, int target) &#123;        return new int[]&#123;getFrist(nums,target), getLast(nums,target)&#125;;    &#125;    public static int getFrist(int[] nums, int target)&#123;        int l = 0;        int r = nums.length;        while(l &lt; r)&#123;            int mid = l + (r-l)/2;            if( nums[mid] == target)&#123;                r = mid;            &#125;else if( nums[mid] &gt; target)&#123;                r = mid;            &#125;else&#123;                l = mid+1;            &#125;        &#125;        if( l == nums.length) return -1;        if( nums[l] ==target) return l;        return -1;    &#125;    public static int getLast(int[] nums, int target)&#123;        int l = 0;        int r = nums.length;        while(l &lt; r)&#123;            int mid = l + (r-l)/2;            if( nums[mid] == target)&#123;               l = mid+1;            &#125;else if( nums[mid] &gt; target)&#123;                r = mid;            &#125;else&#123;                l = mid+1;            &#125;        &#125;        if(r == 0) return -1;        if(nums[r - 1] ==target) return r-1;        return  -1;    &#125;&#125;</code></pre><p>模板</p><pre><code class="java">int left = 0;int right = num.length;while(left &lt; right)&#123;    int mid = left + (right - left)/2;    if(nums[mid] &lt; target)&#123;        left = mid+1;    &#125;else&#123;        right = mid    &#125;&#125;return left;</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>如果不要求时间复杂度，只需要分别正序遍历找左边target和逆序遍历找右边target即可。但是根据题目要求的时间复杂度O(log n)，看出这依然是一个二分查找的变种。</p><h2 id="思路一：二分法再线性法"><a href="#思路一：二分法再线性法" class="headerlink" title="思路一：二分法再线性法"></a>思路一：二分法再线性法</h2><p>二分法找到target，如果不存在则返回[-1,-1]。<br>如果nums[mid]==target，利用数组有序的特点， 以mid为中心分别向左向右线性查找，找到最左和最右的target值。</p><pre><code class="java">public int[] searchRange(int[] nums, int target) &#123;        int[] result=&#123;-1,-1&#125;;        int left=0,right=nums.length-1;        //先二分法找到target的下标        while (left&lt;=right)&#123;            int mid=(left+right)/2;            //如果找到target的下标mid，就以mid为中心分别向左向右线性查找            if (nums[mid]==target)&#123;                int left_key=mid,right_key=mid;                //向左向右线性查找，直至找到不等于target                while (left_key&gt;=0&amp;&amp;nums[left_key]==target)left_key--;                while (right_key&lt;nums.length&amp;&amp;nums[right_key]==target)right_key++;                //保存最左和最右的target值的下标                result[0]=left_key+1;                result[1]=right_key-1;                //终止二分法                break;            &#125;else if (nums[mid]&lt;target)&#123;               left=mid+1;            &#125;else if (nums[mid]&gt;target)&#123;                right=mid-1;            &#125;        &#125;        return result;    &#125;</code></pre><p>最坏情况，有序数组中元素都等于target，例如target=8，[8,8,8,8,8,8]，则线性寻找最左最右时需要遍历每个元素。所以时间复杂度是：O(n)。但是因为测试数据的关系，leetcode中这种思路也是可以通过的。</p><h2 id="思路二：直接二分法分别查找"><a href="#思路二：直接二分法分别查找" class="headerlink" title="思路二：直接二分法分别查找"></a>思路二：直接二分法分别查找</h2><p>嘴笨，说的比较抽象，其实根据下述方法，动笔在纸上画一画模拟一下就很清晰明了了。</p><p>二分法查找最左target：如果中间值(nums[mid])不等于target，则根据情况移动left或者right来减半搜索区间范围即可。需要改变的是：当中间值等于target，不能直接返回，而是要收缩right减小搜索区间继续逐步锁定最左的target。<br>最终得到的left(因为循环终止条件时right==left，所以最终left和right是相等的)可以理解成：数组中比target小的元素的个数。所以最终进行简单的判断即可，如果<code>left==nums.length</code>说明所有的数都比target小则返回-1，如果<code>nums[left]==target</code>则nums[left]就是最左的target，否则数组中没有target返回-1。<br>二分法查找最右target：如果中间值(nums[mid])不等于target，则根据情况移动left或者right来减半搜索区间范围即可。需要改变的是：当中间值等于target，不能直接返回，而是要增加left减小搜索区间继续逐步锁定最右的target。<br>因为搜索区间是[0，nums.length)为左闭右开，所以最后判断和返回时需要对left或者right减一，防止越界。这个”减一”也可以这么理解：’if (nums[mid]==target)left=mid+1;’当while循环结束的时候nums[left]的值一定不是target，但是nums[left-1]的值有可能是，所以返回‘nums[right-1]==target?right-1:-1’即可。</p><pre><code class="java">public int[] searchRange(int[] nums, int target) &#123;    int[] result=&#123;-1,-1&#125;;    result[0]=searchLeft(nums,target);    result[1]=searchRight(nums,target);    return result;&#125;//查找最左targetpublic int searchLeft(int[] nums,int target)&#123;    int left=0,right=nums.length;    //这里是&lt;而不是&lt;=，因为搜索区间是[0，length)，终止条件是left==right    while (left&lt;right)&#123;        int mid =(left+right)/2;        //因为是寻找最左target，所以这里不能直接返回，而是收缩right去锁定左侧边界        if (nums[mid]==target)&#123;            right=mid;        &#125;else if (nums[mid]&lt;target)&#123;            left=mid+1;        &#125;else if (nums[mid]&gt;target)&#123;            //这里是=mid而不是=mid-1，因为搜索区间是左闭右开            right=mid;        &#125;    &#125;    //如果target比所有数都大，则返回-1    if (left==nums.length)return -1;    //终止条件是left==right，所以返回left或者right都可    return nums[left]==target?left:-1;&#125;//寻找最右targetpublic int searchRight(int[] nums,int target)&#123;    int left=0,right=nums.length;    //这里是&lt;而不是&lt;=，因为搜索区间是[0，length)    while (left&lt;right)&#123;        int mid=(left+right)/2;        //因为是寻找最右target，所以不能直接返回，而是要增大left去锁定左侧边界        if (nums[mid]==target)&#123;            left=mid+1;        &#125;else if (nums[mid]&gt;target)&#123;            right=mid;        &#125;else if (nums[mid]&lt;target)&#123;            left=mid+1;        &#125;    &#125;    if (right==0)return -1;    //由于每次收紧左侧边界都是left=mid+1（因为搜索区间是左闭右开），所以无论是left还是right都需要-1    return nums[right-1]==target?right-1:-1;&#125;</code></pre><p>时间复杂度：O(log n)</p><p>注意事项：<br>二分法中比较麻烦容易出错的点就是搜索区间的确定，因为这会影响到循环条件和搜索区间端点(left和right)的移动。<br>思路一中：left=0，right=length-1所以搜索区间是[0，length-1]左闭右闭的，所以循环终止的条件是left&gt;right即while(left&lt;=right)，区间端点移动时因为mid不是需要的值所以排除，即left=mid+1，right=mid-1排除了mid并且新的搜索区间是[0，mid-1]或者[mid+1，lenght-1]依然是左闭右闭。<br>思路二中：left=0，right=length所以搜索区间是[0，length)左闭右开的，所以循环终止的条件是left==right所以while(left&lt;right)即可，区间端点移动时因为mid不是需要的值所以排除，即left=mid+1，right=mid排除了mid并且新的搜索区间是[0，mid)或者[mid+1，lenght)依然是左闭右闭。</p><p>作者：jerrymouse1998<br>链接：<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-fa-de-liang-chong-bian-xing-fang-shi-by-da-/">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-fa-de-liang-chong-bian-xing-fang-shi-by-da-/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h1 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h1><pre><code class="java">public class test &#123;    public static void main(String[] args) &#123;        int[] nums = new int[]&#123;5,7,7,8,8,10&#125;;        int target = 11;        int l = 0;        int r = nums.length;        while(l &lt; r)&#123;            int mid = l + (r-l)/2;            if( nums[mid] == target)&#123;                r = mid;            &#125;else if( nums[mid] &gt; target)&#123;                r = mid;            &#125;else&#123;                l = mid+1;            &#125;        &#125;        if( l == nums.length) System.out.println(&quot;l为&quot;+l+&quot;nums.length为&quot;+nums.length);        if( nums[l] ==target) System.out.println(&quot;l为&quot;+l);;    &#125;</code></pre><p>输入为</p><pre><code class="java">l为6  nums.length为6</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 二分搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>704. 二分查找</title>
      <link href="2020/09/22/704.%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>2020/09/22/704.%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a href="https://leetcode-cn.com/problems/binary-search/">704. 二分查找</a></h1><p>难度简单158</p><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p><p><strong>示例 1:</strong></p><pre><code>输入: nums = [-1,0,3,5,9,12], target = 9输出: 4解释: 9 出现在 nums 中并且下标为 4</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: nums = [-1,0,3,5,9,12], target = 2输出: -1解释: 2 不存在 nums 中因此返回 -1</code></pre><p><strong>提示：</strong></p><ol><li>你可以假设 <code>nums</code> 中的所有元素是不重复的。</li><li><code>n</code> 将在 <code>[1, 10000]</code>之间。</li><li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间。</li></ol><p>通过次数68,350</p><p>提交次数124,083</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public int search(int[] nums, int target) &#123;        int left = 0;        int right = nums.length;        while(left &lt; right)&#123;            int mid = left + (right - left)/2;            if( nums[mid] &gt; target)&#123;                right = mid;            &#125;else if(nums[mid] &lt; target)&#123;                left = mid+1;            &#125;else&#123;                return mid;            &#125;        &#125;        return -1;    &#125;&#125;</code></pre><p>模板</p><pre><code class="java">int left = 0;int right = num.length;while(left &lt; right)&#123;    int mid = left + (right - left)/2;    if(nums[mid] &lt; target)&#123;        left = mid+1;    &#125;else&#123;        right = mid    &#125;&#125;return left;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 二分搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15. 三数之和</title>
      <link href="2020/09/22/15.%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>2020/09/22/15.%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></h1><p>难度中等2596</p><p>给你一个包含 <em>n</em> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a，b，c ，</em>使得 <em>a + b + c =</em> 0 ？请你找出所有满足条件且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例：</strong></p><pre><code>给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[  [-1, 0, 1],  [-1, -1, 2]]</code></pre><p>通过次数330,688</p><p>提交次数1,119,900</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();        Arrays.sort(nums);        for(int i=0; i &lt; nums.length; i++)&#123;            int target = 0 - nums[i];            int left = i+1;            int right = nums.length-1;            if(nums[i] &gt;0) break; //如果当前的值都&gt;0，肯定不会再和其他的2个数相加为0            if(i==0 || nums[i] != nums[i-1])&#123; //相同数字去重                while( left &lt; right)&#123;                    if( nums[left] + nums[right] == target)&#123;                        List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();                        temp.add(nums[i]);                        temp.add(nums[left]);                        temp.add(nums[right]);                        res.add(temp);                        //相同数字去重                        while(left&lt; right &amp;&amp; nums[left] == nums[left+1]) left++;                        while(left&lt; right &amp;&amp; nums[right] == nums[right-1]) right--;                        left++;                        right--;                    &#125;else if( nums[left] + nums[right] &gt; target)&#123;                        right--;                    &#125;else&#123;                        left++;                    &#125;                &#125;            &#125;        &#125;        return res;    &#125;&#125;</code></pre><p>注意去重， 相同数字直接略过</p><p>双指针法思路： 固定 3个指针中最左（最小）数字的指针 k，双指针 i，j 分设在数组索引 (k, len(nums))(k,len(nums)) 两端，通过双指针交替向中间移动，记录对于每个固定指针 k 的所有满足 nums[k] + nums[i] + nums[j] == 0 的 i,j 组合：</p><ol><li>nums[k] &gt; 0 时直接break跳出：因为 nums[j] &gt;= nums[i] &gt;= nums[k] &gt; 0，即 33 个数字都大于 00 ，在此固定指针 k 之后不可能再找到结果了。</li><li>当 k &gt; 0且nums[k] == nums[k - 1]时即跳过此元素nums[k]：因为已经将 nums[k - 1] 的所有组合加入到结果中，本次双指针搜索只会得到重复组合。</li><li>i，j 分设在数组索引 (k, len(nums))(k,len(nums)) 两端，当i &lt; j时循环计算s = nums[k] + nums[i] + nums[j]，并按照以下规则执行双指针移动：<br>当s &lt; 0时，i += 1并跳过所有重复的nums[i]；<br>当s &gt; 0时，j -= 1并跳过所有重复的nums[j]；<br>当s == 0时，记录组合[k, i, j]至res，执行i += 1和j -= 1并跳过所有重复的nums[i]和nums[j]，防止记录到重复组合。<br>复杂度分析：<br>时间复杂度 O(N^2)O(N </li></ol><h1 id="利用hashset去重"><a href="#利用hashset去重" class="headerlink" title="利用hashset去重"></a>利用hashset去重</h1><pre><code class="java">class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;        Set&lt;List&lt;Integer&gt;&gt; list = new HashSet&lt;&gt;();        Arrays.sort(nums);        for(int i= 0; i &lt; nums.length; i++)&#123;            int l = i+1;            int r = nums.length-1;            int diff = 0 - nums[i];            while( l &lt;r)&#123;                int sum = ( nums[l] + nums[r]);                if( sum == diff)&#123;                    List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();                    temp.add(nums[i]);                    temp.add( nums[l]);                    temp.add(nums[r]);                    list.add(temp);                    l++;                    r--;                &#125;else if ( sum &gt; diff)&#123;                    r--;                &#125;else&#123;                    l++;                &#125;            &#125;        &#125;        return new ArrayList&lt;&gt;(list);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 二分搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>144. 二叉树的前序遍历</title>
      <link href="2020/09/19/144.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>2020/09/19/144.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h1 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h1><p>难度中等367</p><p>给定一个二叉树，返回它的 <em>前序</em> 遍历。</p><p> <strong>示例:</strong></p><pre><code>输入: [1,null,2,3]     1    \     2    /   3 输出: [1,2,3]</code></pre><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><p>通过次数171,139</p><p>提交次数255,846</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;        LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();        while( !stack.isEmpty() || root != null)&#123;            while(root!=null)&#123;                res.add(root.val);                stack.add(root);                root = root.left;            &#125;            TreeNode node = stack.pollLast();            root = node.right;        &#125;        return res;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14. 最长公共前缀</title>
      <link href="2020/09/19/14.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
      <url>2020/09/19/14.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
      
        <content type="html"><![CDATA[<h1 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a><a href="https://leetcode-cn.com/problems/longest-common-prefix/">14. 最长公共前缀</a></h1><p>难度简单1271</p><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p><p><strong>示例 1:</strong></p><pre><code>输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot;</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。</code></pre><p><strong>说明:</strong></p><p>所有输入只包含小写字母 <code>a-z</code> 。</p><p>通过次数362,784</p><p>提交次数935,793</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public String longestCommonPrefix(String[] strs) &#123;        if(strs.length ==0) return &quot;&quot;;        String res = strs[0];        for(int i =1 ; i &lt; strs.length;i++)&#123;            int j =0;            for(;j &lt; res.length() &amp;&amp;  j &lt; strs[i].length(); j++)&#123;                if( res.charAt(j) != strs[i].charAt(j)) break;            &#125;            res = res.substring(0,j);            if (res.equals(&quot; &quot;)) return &quot; &quot;;        &#125;        return res;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 二分搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11. 盛最多水的容器</title>
      <link href="2020/09/18/11.%20%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
      <url>2020/09/18/11.%20%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/">11. 盛最多水的容器</a></h1><p>难度中等1844</p><p>给你 <em>n</em> 个非负整数 <em>a</em>1，<em>a</em>2，…，<em>a</em>n，每个数代表坐标中的一个点 (<em>i</em>, <em>ai</em>) 。在坐标内画 <em>n</em> 条垂直线，垂直线 <em>i</em> 的两个端点分别为 (<em>i</em>, <em>ai</em>) 和 (<em>i</em>, 0)。找出其中的两条线，使得它们与 <em>x</em> 轴共同构成的容器可以容纳最多的水。</p><p><strong>说明：</strong>你不能倾斜容器，且 <em>n</em> 的值至少为 2。</p><p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img"></p><p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><p><strong>示例：</strong></p><pre><code>输入：[1,8,6,2,5,4,8,3,7]输出：49</code></pre><p>通过次数286,240</p><p>提交次数445,940</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>暴力法</p><pre><code class="java">class Solution &#123;    public int maxArea(int[] height) &#123;        int curArea = 0;        int maxArea = 0;        for(int i =0; i &lt; height.length; i++)&#123;            for(int j =i+1; j &lt; height.length; j++)&#123;                curArea = (j-i) * Math.min(height[i], height[j]);                if(curArea &gt; maxArea) maxArea = curArea;            &#125;        &#125;        return maxArea;    &#125;&#125;</code></pre><p>双指针移动， 由于水桶的体积主要取决一最短的边，因此指针在移动的时候，只需要移动最短的边就可以了，而不是双指针都移动</p><pre><code class="java">class Solution &#123;    public int maxArea(int[] height) &#123;        int left = 0;        int right = height.length-1;        int curArea = 0;        int maxArea = 0;        while( left &lt; right)&#123;            curArea = height[left] &lt; height[right] ?                 (right - left) * height[left++]:                (right - left) * height[right--];            if(curArea&gt;maxArea) maxArea = curArea;        &#125;        return maxArea;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>58. 最后一个单词的长度</title>
      <link href="2020/09/17/58.%20%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/"/>
      <url>2020/09/17/58.%20%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="58-最后一个单词的长度"><a href="#58-最后一个单词的长度" class="headerlink" title="58. 最后一个单词的长度"></a><a href="https://leetcode-cn.com/problems/length-of-last-word/">58. 最后一个单词的长度</a></h1><p>难度简单241</p><p>给定一个仅包含大小写字母和空格 <code>&#39; &#39;</code> 的字符串 <code>s</code>，返回其最后一个单词的长度。如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。</p><p>如果不存在最后一个单词，请返回 0 。</p><p><strong>说明：</strong>一个单词是指仅由字母组成、不包含任何空格字符的 <strong>最大子字符串</strong>。</p><p><strong>示例:</strong></p><pre><code>输入: &quot;Hello World&quot;输出: 5</code></pre><p>通过次数125,070</p><p>提交次数371,129</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="python">class Solution:    def lengthOfLastWord(self, s: str) -&gt; int:        s = s.strip()        count = 0        for i in s[::-1]:            if i != &#39; &#39;:                count +=1            else:                break        return count</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1054. 距离相等的条形码</title>
      <link href="2020/09/17/1054.%20%E8%B7%9D%E7%A6%BB%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9D%A1%E5%BD%A2%E7%A0%81/"/>
      <url>2020/09/17/1054.%20%E8%B7%9D%E7%A6%BB%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9D%A1%E5%BD%A2%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="1054-距离相等的条形码"><a href="#1054-距离相等的条形码" class="headerlink" title="1054. 距离相等的条形码"></a><a href="https://leetcode-cn.com/problems/distant-barcodes/">1054. 距离相等的条形码</a></h1><p>难度中等44收藏分享切换为英文关注反馈</p><p>在一个仓库里，有一排条形码，其中第 <code>i</code> 个条形码为 <code>barcodes[i]</code>。</p><p>请你重新排列这些条形码，使其中两个相邻的条形码 <strong>不能</strong> 相等。 你可以返回任何满足该要求的答案，此题保证存在答案。</p><p><strong>示例 1：</strong></p><pre><code>输入：[1,1,1,2,2,2]输出：[2,1,2,1,2,1]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：[1,1,1,1,2,2,3,3]输出：[1,3,1,3,2,1,2,1]</code></pre><p><strong>提示：</strong></p><ol><li><code>1 &lt;= barcodes.length &lt;= 10000</code></li><li><code>1 &lt;= barcodes[i] &lt;= 10000</code></li></ol><p>通过次数5,049</p><p>提交次数14,374</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="python">class Solution:    def rearrangeBarcodes(self, barcodes: List[int]) -&gt; List[int]:        arr = barcodes        for i in range(len(arr)-1):            if arr[i] == arr[i+1] :                for j in range(i,len(arr)):                    if arr[i] != arr[j]:                        arr[i+1],arr[j] = arr[j], arr[i+1]                        break        for i in range(len(arr)-1,-1,-1):            if arr[i] == arr[i-1]:                for j in range(i,-1,-1):                    if arr[i] != arr[j]:                        arr[i-1], arr[j] = arr[j],arr[i-1]                        break        return arr</code></pre><p>从左到右进行遍历，再从右至左遍历</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题 02.01. 移除重复节点</title>
      <link href="2020/09/16/%E9%9D%A2%E8%AF%95%E9%A2%98%2002.01.%20%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/"/>
      <url>2020/09/16/%E9%9D%A2%E8%AF%95%E9%A2%98%2002.01.%20%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="面试题-02-01-移除重复节点"><a href="#面试题-02-01-移除重复节点" class="headerlink" title="面试题 02.01. 移除重复节点"></a><a href="https://leetcode-cn.com/problems/remove-duplicate-node-lcci/">面试题 02.01. 移除重复节点</a></h1><p>难度简单65</p><p>编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。</p><p><strong>示例1:</strong></p><pre><code> 输入：[1, 2, 3, 3, 2, 1] 输出：[1, 2, 3]</code></pre><p><strong>示例2:</strong></p><pre><code> 输入：[1, 1, 1, 1, 2] 输出：[1, 2]</code></pre><p><strong>提示：</strong></p><ol><li>链表长度在[0, 20000]范围内。</li><li>链表元素在[0, 20000]范围内。</li></ol><p><strong>进阶：</strong></p><p>如果不得使用临时缓冲区，该怎么解决？</p><p>通过次数35,417</p><p>提交次数50,758</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="python"># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def removeDuplicateNodes(self, head: ListNode) -&gt; ListNode:        if not head : return None        ret = head        res = [head.val]        while head and head.next:            if head.next.val not in res:                res.append(head.next.val)                head = head.next            else:                head.next = head.next.next        return ret</code></pre><p>注意点： 在移除重复的节点前， 先要把第一个结点的值放到list里面， 再判断下一个结点的值</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>459. 重复的子字符串</title>
      <link href="2020/09/16/459.%20%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>2020/09/16/459.%20%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459. 重复的子字符串"></a><a href="https://leetcode-cn.com/problems/repeated-substring-pattern/">459. 重复的子字符串</a></h1><p>难度简单357</p><p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p><p><strong>示例 1:</strong></p><pre><code>输入: &quot;abab&quot;输出: True解释: 可由子字符串 &quot;ab&quot; 重复两次构成。</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: &quot;aba&quot;输出: False</code></pre><p><strong>示例 3:</strong></p><pre><code>输入: &quot;abcabcabcabc&quot;输出: True解释: 可由子字符串 &quot;abc&quot; 重复四次构成。 (或者子字符串 &quot;abcabc&quot; 重复两次构成。)</code></pre><p>通过次数51,221</p><p>提交次数99,595</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="python">class Solution:    def repeatedSubstringPattern(self, s: str) -&gt; bool:        for i in range(1, len(s)):            if s[0:i] * (len(s)//i) ==s:                return True        return False</code></pre><p>暴力破解</p><p>在真实的面试中遇到过这道题？</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>35.搜索插入位置</title>
      <link href="2020/09/15/35.%20%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
      <url>2020/09/15/35.%20%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a><a href="https://leetcode-cn.com/problems/search-insert-position/">35. 搜索插入位置</a></h1><p>难度简单684收藏分享切换为英文关注反馈</p><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p><strong>示例 1:</strong></p><pre><code class="java">输入: [1,3,5,6], 5输出: 2</code></pre><p><strong>示例 2:</strong></p><pre><code class="java">输入: [1,3,5,6], 2输出: 1</code></pre><p><strong>示例 3:</strong></p><pre><code class="java">输入: [1,3,5,6], 7输出: 4</code></pre><p><strong>示例 4:</strong></p><pre><code class="java">输入: [1,3,5,6], 0输出: 0</code></pre><p>通过次数247,605</p><p>提交次数530,435</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public int searchInsert(int[] nums, int target) &#123;        int left = 0;        int right = nums.length;        while( left &lt; right)&#123;            int mid = left + ( right - left)/ 2;            if(nums[mid] &lt; target)&#123;                left = mid+1;            &#125;else&#123;                right = mid;            &#125;        &#125;        return left;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>26. 删除排序数组中的重复项</title>
      <link href="2020/09/15/26.%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
      <url>2020/09/15/26.%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26. 删除排序数组中的重复项"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">26. 删除排序数组中的重复项</a></h1><p>难度简单1635</p><p>给定一个排序数组，你需要在**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p><p><strong>示例 1:</strong></p><pre><code class="java">给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。</code></pre><p><strong>示例 2:</strong></p><pre><code class="java">给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。</code></pre><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><pre><code class="java">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123;    print(nums[i]);&#125;</code></pre><p>通过次数423,173</p><p>提交次数818,559</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>利用双指针</p><pre><code class="java">class Solution &#123;    public int removeDuplicates(int[] nums) &#123;       //[0,0,1,1,1,2,2,3,3,4]       // p   q        int p = 0;       int q = 1;       while( q &lt; nums.length)&#123;           if( nums[q] &gt; nums[p])&#123;               nums[p+1] = nums[q];               p++;           &#125;           q++;       &#125;        return p+1;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题 17.10. 主要元素</title>
      <link href="2020/09/15/%E9%9D%A2%E8%AF%95%E9%A2%98%2017.10.%20%E4%B8%BB%E8%A6%81%E5%85%83%E7%B4%A0/"/>
      <url>2020/09/15/%E9%9D%A2%E8%AF%95%E9%A2%98%2017.10.%20%E4%B8%BB%E8%A6%81%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="面试题-17-10-主要元素"><a href="#面试题-17-10-主要元素" class="headerlink" title="面试题 17.10. 主要元素"></a><a href="https://leetcode-cn.com/problems/find-majority-element-lcci/">面试题 17.10. 主要元素</a></h1><p>难度简单27</p><p>数组中占比超过一半的元素称之为主要元素。给定一个<strong>整数</strong>数组，找到它的主要元素。若没有，返回-1。</p><p><strong>示例 1：</strong></p><pre><code>输入：[1,2,5,9,5,9,5,5,5]输出：5</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：[3,2]输出：-1</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：[2,2,1,1,1,2,2]输出：2</code></pre><p><strong>说明：</strong><br>你有办法在时间复杂度为 O(N)，空间复杂度为 O(1) 内完成吗？</p><p>通过次数13,487</p><p>提交次数20,963</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public int majorityElement(int[] nums) &#123;        if(nums.length ==1) return nums[0];        int MidLens = nums.length / 2;        HashMap&lt;Integer, Integer&gt; m = new HashMap&lt;&gt;();        for(int i =0; i&lt; nums.length; i++)&#123;            if(m.containsKey( nums[i]))&#123;                Integer temp = m.get(nums[i]);                temp++;                if(temp &gt; MidLens) return nums[i];                m.put(nums[i], temp);            &#125;else&#123;                m.put(nums[i],1);            &#125;        &#125;        return -1;    &#125;&#125;</code></pre><pre><code class="python">class Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        if len(nums) ==1 : return nums[0]        mid = len(nums) // 2        m = &#123;&#125;        for i in nums:            if i in m:                count = m[i]                count +=1                if(count &gt; mid): return i                m[i] = count             else:                m[i] = 1        return -1</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1260. 二维网格迁移</title>
      <link href="2020/09/14/1260.%20%E4%BA%8C%E7%BB%B4%E7%BD%91%E6%A0%BC%E8%BF%81%E7%A7%BB/"/>
      <url>2020/09/14/1260.%20%E4%BA%8C%E7%BB%B4%E7%BD%91%E6%A0%BC%E8%BF%81%E7%A7%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="1260-二维网格迁移"><a href="#1260-二维网格迁移" class="headerlink" title="1260. 二维网格迁移"></a><a href="https://leetcode-cn.com/problems/shift-2d-grid/">1260. 二维网格迁移</a></h1><p>难度简单32</p><p>给你一个 <code>m</code> 行 <code>n</code> 列的二维网格 <code>grid</code> 和一个整数 <code>k</code>。你需要将 <code>grid</code> 迁移 <code>k</code> 次。</p><p>每次「迁移」操作将会引发下述活动：</p><ul><li>位于 <code>grid[i][j]</code> 的元素将会移动到 <code>grid[i][j + 1]</code>。</li><li>位于 <code>grid[i][n - 1]</code> 的元素将会移动到 <code>grid[i + 1][0]</code>。</li><li>位于 <code>grid[m - 1][n - 1]</code> 的元素将会移动到 <code>grid[0][0]</code>。</li></ul><p>请你返回 <code>k</code> 次迁移操作后最终得到的 <strong>二维网格</strong>。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/16/e1-1.png" alt="img"></p><pre><code>输入：grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1输出：[[9,1,2],[3,4,5],[6,7,8]]</code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/16/e2-1.png" alt="img"></p><pre><code>输入：grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4输出：[[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9输出：[[1,2,3],[4,5,6],[7,8,9]]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= grid.length &lt;= 50</code></li><li><code>1 &lt;= grid[i].length &lt;= 50</code></li><li><code>-1000 &lt;= grid[i][j] &lt;= 1000</code></li><li><code>0 &lt;= k &lt;= 100</code></li></ul><p>通过次数6,902</p><p>提交次数11,429</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; shiftGrid(int[][] grid, int k) &#123;        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();        int m = grid.length;        int n = grid[0].length;        int[][] ret= new int[m][n];        for(int i =0; i &lt; m;i++)&#123;            for(int j =0; j &lt; n; j++)&#123;                ret[((j + k )/n +i) % m  ][ (j +k) % n] = grid[i][j];            &#125;        &#125;        for(int i =0 ; i &lt; ret.length;i++)&#123;            List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();            for(int j=0; j&lt; ret[0].length; j++)&#123;                temp.add(ret[i][j]);            &#125;            res.add(temp);        &#125;        return res;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>225. 用队列实现栈</title>
      <link href="2020/09/14/225.%20%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
      <url>2020/09/14/225.%20%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h1><p>难度简单223收藏分享切换为英文关注反馈</p><p>使用队列实现栈的下列操作：</p><ul><li>push(x) – 元素 x 入栈</li><li>pop() – 移除栈顶元素</li><li>top() – 获取栈顶元素</li><li>empty() – 返回栈是否为空</li></ul><p><strong>注意:</strong></p><ul><li>你只能使用队列的基本操作– 也就是 <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code>, 和 <code>is empty</code> 这些操作是合法的。</li><li>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li><li>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</li></ul><p>通过次数72,158</p><p>提交次数110,101</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class MyStack &#123;    LinkedList&lt;Integer&gt; queue1 = new LinkedList&lt;&gt;();    LinkedList&lt;Integer&gt; queue2 = new LinkedList&lt;&gt;();    /** Initialize your data structure here. */    public MyStack() &#123;    &#125;    /** Push element x onto stack. */    public void push(int x) &#123;        queue1.add(x);    &#125;    /** Removes the element on top of the stack and returns that element. */    public int pop() &#123;        while(queue1.size() &gt;1)&#123;            queue2.add(queue1.pollFirst());        &#125;        Integer ret = queue1.pollFirst();        while(!queue2.isEmpty())&#123;            queue1.add(queue2.pollFirst());        &#125;        return ret;    &#125;    /** Get the top element. */    public int top() &#123;        while(queue1.size() &gt;1)&#123;            queue2.add(queue1.pollFirst());        &#125;        Integer ret = queue1.peekFirst();        queue2.add(queue1.pollFirst());        while(!queue2.isEmpty())&#123;            queue1.add(queue2.pollFirst());        &#125;        return ret;    &#125;    /** Returns whether the stack is empty. */    public boolean empty() &#123;        return queue1.isEmpty();    &#125;&#125;/** * Your MyStack object will be instantiated and called as such: * MyStack obj = new MyStack(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.top(); * boolean param_4 = obj.empty(); */</code></pre><p>利用双队列来模拟栈</p><p>注意点， 始终保持queue1为主队列</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 栈，队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1576. 替换所有的问号</title>
      <link href="2020/09/14/1576.%20%E6%9B%BF%E6%8D%A2%E6%89%80%E6%9C%89%E7%9A%84%E9%97%AE%E5%8F%B7/"/>
      <url>2020/09/14/1576.%20%E6%9B%BF%E6%8D%A2%E6%89%80%E6%9C%89%E7%9A%84%E9%97%AE%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="1576-替换所有的问号"><a href="#1576-替换所有的问号" class="headerlink" title="1576. 替换所有的问号"></a><a href="https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/">1576. 替换所有的问号</a></h1><p>难度简单5收藏分享切换为英文关注反馈</p><p>给你一个仅包含小写英文字母和 <code>&#39;?&#39;</code> 字符的字符串 <code>s</code>，请你将所有的 <code>&#39;?&#39;</code> 转换为若干小写字母，使最终的字符串不包含任何 <strong>连续重复</strong> 的字符。</p><p>注意：你 <strong>不能</strong> 修改非 <code>&#39;?&#39;</code> 字符。</p><p>题目测试用例保证 <strong>除</strong> <code>&#39;?&#39;</code> 字符 <strong>之外</strong>，不存在连续重复的字符。</p><p>在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。</p><p><strong>示例 1：</strong></p><pre><code class="java">输入：s = &quot;?zs&quot;输出：&quot;azs&quot;解释：该示例共有 25 种解决方案，从 &quot;azs&quot; 到 &quot;yzs&quot; 都是符合题目要求的。只有 &quot;z&quot; 是无效的修改，因为字符串 &quot;zzs&quot; 中有连续重复的两个 &#39;z&#39; 。</code></pre><p><strong>示例 2：</strong></p><pre><code class="java">输入：s = &quot;ubv?w&quot;输出：&quot;ubvaw&quot;解释：该示例共有 24 种解决方案，只有替换成 &quot;v&quot; 和 &quot;w&quot; 不符合题目要求。因为 &quot;ubvvw&quot; 和 &quot;ubvww&quot; 都包含连续重复的字符。</code></pre><p><strong>示例 3：</strong></p><pre><code class="java">输入：s = &quot;j?qg??b&quot;输出：&quot;jaqgacb&quot;</code></pre><p><strong>示例 4：</strong></p><pre><code class="java">输入：s = &quot;??yw?ipkj?&quot;输出：&quot;acywaipkja&quot;</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> 仅包含小写英文字母和 <code>&#39;?&#39;</code> 字符</li></ul><p>通过次数5,305</p><p>提交次数10,740</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public String modifyString(String s) &#123;        char[] str = s.toCharArray();        char[] strList = &#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;g&#39;,&#39;i&#39;,&#39;j&#39;,&#39;k&#39;,&#39;l&#39;,                &#39;m&#39;,&#39;n&#39;,&#39;o&#39;,&#39;p&#39;,&#39;q&#39;,                &#39;r&#39;,&#39;s&#39;,&#39;t&#39;,&#39;u&#39;,&#39;v&#39;,&#39;w&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;&#125;;        for( int i=0; i &lt; str.length; i++)&#123;            if(str[i] ==&#39;?&#39;)&#123;                char l;                char r;                if(i==0 )&#123;                    l =  &#39; &#39;;                &#125;else&#123;                    l = str[i-1];                &#125;                if(i == str.length-1 )&#123;                    r = &#39; &#39;;                &#125;else&#123;                    r = str[i+1];                &#125;                str[i] = &#39;a&#39;;                for(int j =1; j &lt; strList.length;j++)&#123;                    if( l == str[i] || r == str[i])&#123;                        str[i] = strList[j];                    &#125;else&#123;                        break;                    &#125;                &#125;            &#125;        &#125;        return new String(str);    &#125;&#125;</code></pre><p>关键点：</p><ol><li>遍历的时候，主要将左右边界进行初始化判断</li><li>对于<code>?</code>被替换的值，可以初始化为<code>a</code></li></ol><p>优化解法</p><pre><code class="java">class Solution &#123;    public String modifyString(String s) &#123;        char[] chars = s.toCharArray();        for (int i = 0; i &lt; chars.length; i++) &#123;            if (chars[i] == &#39;?&#39;) &#123;                //前面一个字符  如果当前是第0个的话 字符就为‘ ’                char ahead = i == 0 ? &#39; &#39; : chars[i - 1];                //后面一个字符  如果当前是最后一个的话 字符就为‘ ’                char behind  = i == chars.length - 1 ? &#39; &#39; : chars[i + 1];                //从a开始比较  如果对于前面或者后面的话 就+1                char temp = &#39;a&#39;;                while (temp == ahead || temp == behind ) &#123;                    temp++;                &#125;                //找到目标字符后 做替换                chars[i] = temp;            &#125;        &#125;        return new String(chars);    &#125;&#125;</code></pre><p>在String前后添加占位字符</p><pre><code class="java">class Solution &#123;    public String modifyString(String s) &#123;        char[] str = (&#39;0&#39; + s +&#39;0&#39;).toCharArray();        for(int i =1;i &lt; str.length-1 ;i++)&#123;            if(str[i] ==&#39;?&#39;)&#123;                char left = str[i-1];                char right = str[i+1];                char temp = &#39;a&#39;;                while( left== temp || right == temp) temp++;                str[i] = temp;            &#125;        &#125;        return new String(str,1,str.length-2);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
