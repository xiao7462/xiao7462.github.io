<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>34. 在排序数组中查找元素的第一个和最后一个位置</title>
      <link href="2020/09/23/34.%20%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/"/>
      <url>2020/09/23/34.%20%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h1><p>难度中等597收藏分享切换为英文关注反馈</p><p>给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。</p><p>你的算法时间复杂度必须是 <em>O</em>(log <em>n</em>) 级别。</p><p>如果数组中不存在目标值，返回 <code>[-1, -1]</code>。</p><p><strong>示例 1:</strong></p><pre><code class="java">输入: nums = [5,7,7,8,8,10], target = 8输出: [3,4]</code></pre><p><strong>示例 2:</strong></p><pre><code class="java">输入: nums = [5,7,7,8,8,10], target = 6输出: [-1,-1]</code></pre><p>通过次数134,913</p><p>提交次数334,126</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public int[] searchRange(int[] nums, int target) &#123;        return new int[]&#123;getFrist(nums,target), getLast(nums,target)&#125;;    &#125;    public static int getFrist(int[] nums, int target)&#123;        int l = 0;        int r = nums.length;        while(l &lt; r)&#123;            int mid = l + (r-l)/2;            if( nums[mid] == target)&#123;                r = mid;            &#125;else if( nums[mid] &gt; target)&#123;                r = mid;            &#125;else&#123;                l = mid+1;            &#125;        &#125;        if( l == nums.length) return -1;        if( nums[l] ==target) return l;        return -1;    &#125;    public static int getLast(int[] nums, int target)&#123;        int l = 0;        int r = nums.length;        while(l &lt; r)&#123;            int mid = l + (r-l)/2;            if( nums[mid] == target)&#123;               l = mid+1;            &#125;else if( nums[mid] &gt; target)&#123;                r = mid;            &#125;else&#123;                l = mid+1;            &#125;        &#125;        if(r == 0) return -1;        if(nums[r - 1] ==target) return r-1;        return  -1;    &#125;&#125;</code></pre><p>模板</p><pre><code class="java">int left = 0;int right = num.length;while(left &lt; right)&#123;    int mid = left + (right - left)/2;    if(nums[mid] &lt; target)&#123;        left = mid+1;    &#125;else&#123;        right = mid    &#125;&#125;return left;</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>如果不要求时间复杂度，只需要分别正序遍历找左边target和逆序遍历找右边target即可。但是根据题目要求的时间复杂度O(log n)，看出这依然是一个二分查找的变种。</p><h2 id="思路一：二分法再线性法"><a href="#思路一：二分法再线性法" class="headerlink" title="思路一：二分法再线性法"></a>思路一：二分法再线性法</h2><p>二分法找到target，如果不存在则返回[-1,-1]。<br>如果nums[mid]==target，利用数组有序的特点， 以mid为中心分别向左向右线性查找，找到最左和最右的target值。</p><pre><code class="java">public int[] searchRange(int[] nums, int target) &#123;        int[] result=&#123;-1,-1&#125;;        int left=0,right=nums.length-1;        //先二分法找到target的下标        while (left&lt;=right)&#123;            int mid=(left+right)/2;            //如果找到target的下标mid，就以mid为中心分别向左向右线性查找            if (nums[mid]==target)&#123;                int left_key=mid,right_key=mid;                //向左向右线性查找，直至找到不等于target                while (left_key&gt;=0&amp;&amp;nums[left_key]==target)left_key--;                while (right_key&lt;nums.length&amp;&amp;nums[right_key]==target)right_key++;                //保存最左和最右的target值的下标                result[0]=left_key+1;                result[1]=right_key-1;                //终止二分法                break;            &#125;else if (nums[mid]&lt;target)&#123;               left=mid+1;            &#125;else if (nums[mid]&gt;target)&#123;                right=mid-1;            &#125;        &#125;        return result;    &#125;</code></pre><p>最坏情况，有序数组中元素都等于target，例如target=8，[8,8,8,8,8,8]，则线性寻找最左最右时需要遍历每个元素。所以时间复杂度是：O(n)。但是因为测试数据的关系，leetcode中这种思路也是可以通过的。</p><h2 id="思路二：直接二分法分别查找"><a href="#思路二：直接二分法分别查找" class="headerlink" title="思路二：直接二分法分别查找"></a>思路二：直接二分法分别查找</h2><p>嘴笨，说的比较抽象，其实根据下述方法，动笔在纸上画一画模拟一下就很清晰明了了。</p><p>二分法查找最左target：如果中间值(nums[mid])不等于target，则根据情况移动left或者right来减半搜索区间范围即可。需要改变的是：当中间值等于target，不能直接返回，而是要收缩right减小搜索区间继续逐步锁定最左的target。<br>最终得到的left(因为循环终止条件时right==left，所以最终left和right是相等的)可以理解成：数组中比target小的元素的个数。所以最终进行简单的判断即可，如果<code>left==nums.length</code>说明所有的数都比target小则返回-1，如果<code>nums[left]==target</code>则nums[left]就是最左的target，否则数组中没有target返回-1。<br>二分法查找最右target：如果中间值(nums[mid])不等于target，则根据情况移动left或者right来减半搜索区间范围即可。需要改变的是：当中间值等于target，不能直接返回，而是要增加left减小搜索区间继续逐步锁定最右的target。<br>因为搜索区间是[0，nums.length)为左闭右开，所以最后判断和返回时需要对left或者right减一，防止越界。这个”减一”也可以这么理解：’if (nums[mid]==target)left=mid+1;’当while循环结束的时候nums[left]的值一定不是target，但是nums[left-1]的值有可能是，所以返回‘nums[right-1]==target?right-1:-1’即可。</p><pre><code class="java">public int[] searchRange(int[] nums, int target) &#123;    int[] result=&#123;-1,-1&#125;;    result[0]=searchLeft(nums,target);    result[1]=searchRight(nums,target);    return result;&#125;//查找最左targetpublic int searchLeft(int[] nums,int target)&#123;    int left=0,right=nums.length;    //这里是&lt;而不是&lt;=，因为搜索区间是[0，length)，终止条件是left==right    while (left&lt;right)&#123;        int mid =(left+right)/2;        //因为是寻找最左target，所以这里不能直接返回，而是收缩right去锁定左侧边界        if (nums[mid]==target)&#123;            right=mid;        &#125;else if (nums[mid]&lt;target)&#123;            left=mid+1;        &#125;else if (nums[mid]&gt;target)&#123;            //这里是=mid而不是=mid-1，因为搜索区间是左闭右开            right=mid;        &#125;    &#125;    //如果target比所有数都大，则返回-1    if (left==nums.length)return -1;    //终止条件是left==right，所以返回left或者right都可    return nums[left]==target?left:-1;&#125;//寻找最右targetpublic int searchRight(int[] nums,int target)&#123;    int left=0,right=nums.length;    //这里是&lt;而不是&lt;=，因为搜索区间是[0，length)    while (left&lt;right)&#123;        int mid=(left+right)/2;        //因为是寻找最右target，所以不能直接返回，而是要增大left去锁定左侧边界        if (nums[mid]==target)&#123;            left=mid+1;        &#125;else if (nums[mid]&gt;target)&#123;            right=mid;        &#125;else if (nums[mid]&lt;target)&#123;            left=mid+1;        &#125;    &#125;    if (right==0)return -1;    //由于每次收紧左侧边界都是left=mid+1（因为搜索区间是左闭右开），所以无论是left还是right都需要-1    return nums[right-1]==target?right-1:-1;&#125;</code></pre><p>时间复杂度：O(log n)</p><p>注意事项：<br>二分法中比较麻烦容易出错的点就是搜索区间的确定，因为这会影响到循环条件和搜索区间端点(left和right)的移动。<br>思路一中：left=0，right=length-1所以搜索区间是[0，length-1]左闭右闭的，所以循环终止的条件是left&gt;right即while(left&lt;=right)，区间端点移动时因为mid不是需要的值所以排除，即left=mid+1，right=mid-1排除了mid并且新的搜索区间是[0，mid-1]或者[mid+1，lenght-1]依然是左闭右闭。<br>思路二中：left=0，right=length所以搜索区间是[0，length)左闭右开的，所以循环终止的条件是left==right所以while(left&lt;right)即可，区间端点移动时因为mid不是需要的值所以排除，即left=mid+1，right=mid排除了mid并且新的搜索区间是[0，mid)或者[mid+1，lenght)依然是左闭右闭。</p><p>作者：jerrymouse1998<br>链接：<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-fa-de-liang-chong-bian-xing-fang-shi-by-da-/">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-fa-de-liang-chong-bian-xing-fang-shi-by-da-/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 二分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>704. 二分查找</title>
      <link href="2020/09/22/704.%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>2020/09/22/704.%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a href="https://leetcode-cn.com/problems/binary-search/">704. 二分查找</a></h1><p>难度简单158</p><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p><p><strong>示例 1:</strong></p><pre><code>输入: nums = [-1,0,3,5,9,12], target = 9输出: 4解释: 9 出现在 nums 中并且下标为 4</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: nums = [-1,0,3,5,9,12], target = 2输出: -1解释: 2 不存在 nums 中因此返回 -1</code></pre><p><strong>提示：</strong></p><ol><li>你可以假设 <code>nums</code> 中的所有元素是不重复的。</li><li><code>n</code> 将在 <code>[1, 10000]</code>之间。</li><li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间。</li></ol><p>通过次数68,350</p><p>提交次数124,083</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public int search(int[] nums, int target) &#123;        int left = 0;        int right = nums.length;        while(left &lt; right)&#123;            int mid = left + (right - left)/2;            if( nums[mid] &gt; target)&#123;                right = mid;            &#125;else if(nums[mid] &lt; target)&#123;                left = mid+1;            &#125;else&#123;                return mid;            &#125;        &#125;        return -1;    &#125;&#125;</code></pre><p>模板</p><pre><code class="java">int left = 0;int right = num.length;while(left &lt; right)&#123;    int mid = left + (right - left)/2;    if(nums[mid] &lt; target)&#123;        left = mid+1;    &#125;else&#123;        right = mid    &#125;&#125;return left;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15. 三数之和</title>
      <link href="2020/09/22/15.%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>2020/09/22/15.%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></h1><p>难度中等2596</p><p>给你一个包含 <em>n</em> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a，b，c ，</em>使得 <em>a + b + c =</em> 0 ？请你找出所有满足条件且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例：</strong></p><pre><code>给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[  [-1, 0, 1],  [-1, -1, 2]]</code></pre><p>通过次数330,688</p><p>提交次数1,119,900</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();        Arrays.sort(nums);        for(int i=0; i &lt; nums.length; i++)&#123;            int target = 0 - nums[i];            int left = i+1;            int right = nums.length-1;            if(nums[i] &gt;0) break; //如果当前的值都&gt;0，肯定不会再和其他的2个数相加为0            if(i==0 || nums[i] != nums[i-1])&#123; //相同数字去重                while( left &lt; right)&#123;                    if( nums[left] + nums[right] == target)&#123;                        List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();                        temp.add(nums[i]);                        temp.add(nums[left]);                        temp.add(nums[right]);                        res.add(temp);                        //相同数字去重                        while(left&lt; right &amp;&amp; nums[left] == nums[left+1]) left++;                        while(left&lt; right &amp;&amp; nums[right] == nums[right-1]) right--;                        left++;                        right--;                    &#125;else if( nums[left] + nums[right] &gt; target)&#123;                        right--;                    &#125;else&#123;                        left++;                    &#125;                &#125;            &#125;        &#125;        return res;    &#125;&#125;</code></pre><p>注意去重， 相同数字直接略过</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 二分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>144. 二叉树的前序遍历</title>
      <link href="2020/09/19/144.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>2020/09/19/144.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h1 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h1><p>难度中等367</p><p>给定一个二叉树，返回它的 <em>前序</em> 遍历。</p><p> <strong>示例:</strong></p><pre><code>输入: [1,null,2,3]     1    \     2    /   3 输出: [1,2,3]</code></pre><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><p>通过次数171,139</p><p>提交次数255,846</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;        LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();        while( !stack.isEmpty() || root != null)&#123;            while(root!=null)&#123;                res.add(root.val);                stack.add(root);                root = root.left;            &#125;            TreeNode node = stack.pollLast();            root = node.right;        &#125;        return res;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14. 最长公共前缀</title>
      <link href="2020/09/19/14.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
      <url>2020/09/19/14.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
      
        <content type="html"><![CDATA[<h1 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a><a href="https://leetcode-cn.com/problems/longest-common-prefix/">14. 最长公共前缀</a></h1><p>难度简单1271</p><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p><p><strong>示例 1:</strong></p><pre><code>输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot;</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。</code></pre><p><strong>说明:</strong></p><p>所有输入只包含小写字母 <code>a-z</code> 。</p><p>通过次数362,784</p><p>提交次数935,793</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public String longestCommonPrefix(String[] strs) &#123;        if(strs.length ==0) return &quot;&quot;;        String res = strs[0];        for(int i =1 ; i &lt; strs.length;i++)&#123;            int j =0;            for(;j &lt; res.length() &amp;&amp;  j &lt; strs[i].length(); j++)&#123;                if( res.charAt(j) != strs[i].charAt(j)) break;            &#125;            res = res.substring(0,j);            if (res.equals(&quot; &quot;)) return &quot; &quot;;        &#125;        return res;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 二分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11. 盛最多水的容器</title>
      <link href="2020/09/18/11.%20%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
      <url>2020/09/18/11.%20%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/">11. 盛最多水的容器</a></h1><p>难度中等1844</p><p>给你 <em>n</em> 个非负整数 <em>a</em>1，<em>a</em>2，…，<em>a</em>n，每个数代表坐标中的一个点 (<em>i</em>, <em>ai</em>) 。在坐标内画 <em>n</em> 条垂直线，垂直线 <em>i</em> 的两个端点分别为 (<em>i</em>, <em>ai</em>) 和 (<em>i</em>, 0)。找出其中的两条线，使得它们与 <em>x</em> 轴共同构成的容器可以容纳最多的水。</p><p><strong>说明：</strong>你不能倾斜容器，且 <em>n</em> 的值至少为 2。</p><p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img"></p><p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p><p><strong>示例：</strong></p><pre><code>输入：[1,8,6,2,5,4,8,3,7]输出：49</code></pre><p>通过次数286,240</p><p>提交次数445,940</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>暴力法</p><pre><code class="java">class Solution &#123;    public int maxArea(int[] height) &#123;        int curArea = 0;        int maxArea = 0;        for(int i =0; i &lt; height.length; i++)&#123;            for(int j =i+1; j &lt; height.length; j++)&#123;                curArea = (j-i) * Math.min(height[i], height[j]);                if(curArea &gt; maxArea) maxArea = curArea;            &#125;        &#125;        return maxArea;    &#125;&#125;</code></pre><p>双指针移动， 由于水桶的体积主要取决一最短的边，因此指针在移动的时候，只需要移动最短的边就可以了，而不是双指针都移动</p><pre><code class="java">class Solution &#123;    public int maxArea(int[] height) &#123;        int left = 0;        int right = height.length-1;        int curArea = 0;        int maxArea = 0;        while( left &lt; right)&#123;            curArea = height[left] &lt; height[right] ?                 (right - left) * height[left++]:                (right - left) * height[right--];            if(curArea&gt;maxArea) maxArea = curArea;        &#125;        return maxArea;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>58. 最后一个单词的长度</title>
      <link href="2020/09/17/58.%20%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/"/>
      <url>2020/09/17/58.%20%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="58-最后一个单词的长度"><a href="#58-最后一个单词的长度" class="headerlink" title="58. 最后一个单词的长度"></a><a href="https://leetcode-cn.com/problems/length-of-last-word/">58. 最后一个单词的长度</a></h1><p>难度简单241</p><p>给定一个仅包含大小写字母和空格 <code>&#39; &#39;</code> 的字符串 <code>s</code>，返回其最后一个单词的长度。如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。</p><p>如果不存在最后一个单词，请返回 0 。</p><p><strong>说明：</strong>一个单词是指仅由字母组成、不包含任何空格字符的 <strong>最大子字符串</strong>。</p><p><strong>示例:</strong></p><pre><code>输入: &quot;Hello World&quot;输出: 5</code></pre><p>通过次数125,070</p><p>提交次数371,129</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="python">class Solution:    def lengthOfLastWord(self, s: str) -&gt; int:        s = s.strip()        count = 0        for i in s[::-1]:            if i != &#39; &#39;:                count +=1            else:                break        return count</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1054. 距离相等的条形码</title>
      <link href="2020/09/17/1054.%20%E8%B7%9D%E7%A6%BB%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9D%A1%E5%BD%A2%E7%A0%81/"/>
      <url>2020/09/17/1054.%20%E8%B7%9D%E7%A6%BB%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9D%A1%E5%BD%A2%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="1054-距离相等的条形码"><a href="#1054-距离相等的条形码" class="headerlink" title="1054. 距离相等的条形码"></a><a href="https://leetcode-cn.com/problems/distant-barcodes/">1054. 距离相等的条形码</a></h1><p>难度中等44收藏分享切换为英文关注反馈</p><p>在一个仓库里，有一排条形码，其中第 <code>i</code> 个条形码为 <code>barcodes[i]</code>。</p><p>请你重新排列这些条形码，使其中两个相邻的条形码 <strong>不能</strong> 相等。 你可以返回任何满足该要求的答案，此题保证存在答案。</p><p><strong>示例 1：</strong></p><pre><code>输入：[1,1,1,2,2,2]输出：[2,1,2,1,2,1]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：[1,1,1,1,2,2,3,3]输出：[1,3,1,3,2,1,2,1]</code></pre><p><strong>提示：</strong></p><ol><li><code>1 &lt;= barcodes.length &lt;= 10000</code></li><li><code>1 &lt;= barcodes[i] &lt;= 10000</code></li></ol><p>通过次数5,049</p><p>提交次数14,374</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="python">class Solution:    def rearrangeBarcodes(self, barcodes: List[int]) -&gt; List[int]:        arr = barcodes        for i in range(len(arr)-1):            if arr[i] == arr[i+1] :                for j in range(i,len(arr)):                    if arr[i] != arr[j]:                        arr[i+1],arr[j] = arr[j], arr[i+1]                        break        for i in range(len(arr)-1,-1,-1):            if arr[i] == arr[i-1]:                for j in range(i,-1,-1):                    if arr[i] != arr[j]:                        arr[i-1], arr[j] = arr[j],arr[i-1]                        break        return arr</code></pre><p>从左到右进行遍历，再从右至左遍历</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题 02.01. 移除重复节点</title>
      <link href="2020/09/16/%E9%9D%A2%E8%AF%95%E9%A2%98%2002.01.%20%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/"/>
      <url>2020/09/16/%E9%9D%A2%E8%AF%95%E9%A2%98%2002.01.%20%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="面试题-02-01-移除重复节点"><a href="#面试题-02-01-移除重复节点" class="headerlink" title="面试题 02.01. 移除重复节点"></a><a href="https://leetcode-cn.com/problems/remove-duplicate-node-lcci/">面试题 02.01. 移除重复节点</a></h1><p>难度简单65</p><p>编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。</p><p><strong>示例1:</strong></p><pre><code> 输入：[1, 2, 3, 3, 2, 1] 输出：[1, 2, 3]</code></pre><p><strong>示例2:</strong></p><pre><code> 输入：[1, 1, 1, 1, 2] 输出：[1, 2]</code></pre><p><strong>提示：</strong></p><ol><li>链表长度在[0, 20000]范围内。</li><li>链表元素在[0, 20000]范围内。</li></ol><p><strong>进阶：</strong></p><p>如果不得使用临时缓冲区，该怎么解决？</p><p>通过次数35,417</p><p>提交次数50,758</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="python"># Definition for singly-linked list.# class ListNode:#     def __init__(self, x):#         self.val = x#         self.next = Noneclass Solution:    def removeDuplicateNodes(self, head: ListNode) -&gt; ListNode:        if not head : return None        ret = head        res = [head.val]        while head and head.next:            if head.next.val not in res:                res.append(head.next.val)                head = head.next            else:                head.next = head.next.next        return ret</code></pre><p>注意点： 在移除重复的节点前， 先要把第一个结点的值放到list里面， 再判断下一个结点的值</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>459. 重复的子字符串</title>
      <link href="2020/09/16/459.%20%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>2020/09/16/459.%20%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459. 重复的子字符串"></a><a href="https://leetcode-cn.com/problems/repeated-substring-pattern/">459. 重复的子字符串</a></h1><p>难度简单357</p><p>给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。</p><p><strong>示例 1:</strong></p><pre><code>输入: &quot;abab&quot;输出: True解释: 可由子字符串 &quot;ab&quot; 重复两次构成。</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: &quot;aba&quot;输出: False</code></pre><p><strong>示例 3:</strong></p><pre><code>输入: &quot;abcabcabcabc&quot;输出: True解释: 可由子字符串 &quot;abc&quot; 重复四次构成。 (或者子字符串 &quot;abcabc&quot; 重复两次构成。)</code></pre><p>通过次数51,221</p><p>提交次数99,595</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="python">class Solution:    def repeatedSubstringPattern(self, s: str) -&gt; bool:        for i in range(1, len(s)):            if s[0:i] * (len(s)//i) ==s:                return True        return False</code></pre><p>暴力破解</p><p>在真实的面试中遇到过这道题？</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>35.搜索插入位置</title>
      <link href="2020/09/15/35.%20%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
      <url>2020/09/15/35.%20%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a><a href="https://leetcode-cn.com/problems/search-insert-position/">35. 搜索插入位置</a></h1><p>难度简单684收藏分享切换为英文关注反馈</p><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p><strong>示例 1:</strong></p><pre><code class="java">输入: [1,3,5,6], 5输出: 2</code></pre><p><strong>示例 2:</strong></p><pre><code class="java">输入: [1,3,5,6], 2输出: 1</code></pre><p><strong>示例 3:</strong></p><pre><code class="java">输入: [1,3,5,6], 7输出: 4</code></pre><p><strong>示例 4:</strong></p><pre><code class="java">输入: [1,3,5,6], 0输出: 0</code></pre><p>通过次数247,605</p><p>提交次数530,435</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public int searchInsert(int[] nums, int target) &#123;        int left = 0;        int right = nums.length;        while( left &lt; right)&#123;            int mid = left + ( right - left)/ 2;            if(nums[mid] &lt; target)&#123;                left = mid+1;            &#125;else&#123;                right = mid;            &#125;        &#125;        return left;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>26. 删除排序数组中的重复项</title>
      <link href="2020/09/15/26.%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
      <url>2020/09/15/26.%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26. 删除排序数组中的重复项"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">26. 删除排序数组中的重复项</a></h1><p>难度简单1635</p><p>给定一个排序数组，你需要在**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p><p><strong>示例 1:</strong></p><pre><code class="java">给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。</code></pre><p><strong>示例 2:</strong></p><pre><code class="java">给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。</code></pre><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><pre><code class="java">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123;    print(nums[i]);&#125;</code></pre><p>通过次数423,173</p><p>提交次数818,559</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>利用双指针</p><pre><code class="java">class Solution &#123;    public int removeDuplicates(int[] nums) &#123;       //[0,0,1,1,1,2,2,3,3,4]       // p   q        int p = 0;       int q = 1;       while( q &lt; nums.length)&#123;           if( nums[q] &gt; nums[p])&#123;               nums[p+1] = nums[q];               p++;           &#125;           q++;       &#125;        return p+1;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题 17.10. 主要元素</title>
      <link href="2020/09/15/%E9%9D%A2%E8%AF%95%E9%A2%98%2017.10.%20%E4%B8%BB%E8%A6%81%E5%85%83%E7%B4%A0/"/>
      <url>2020/09/15/%E9%9D%A2%E8%AF%95%E9%A2%98%2017.10.%20%E4%B8%BB%E8%A6%81%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="面试题-17-10-主要元素"><a href="#面试题-17-10-主要元素" class="headerlink" title="面试题 17.10. 主要元素"></a><a href="https://leetcode-cn.com/problems/find-majority-element-lcci/">面试题 17.10. 主要元素</a></h1><p>难度简单27</p><p>数组中占比超过一半的元素称之为主要元素。给定一个<strong>整数</strong>数组，找到它的主要元素。若没有，返回-1。</p><p><strong>示例 1：</strong></p><pre><code>输入：[1,2,5,9,5,9,5,5,5]输出：5</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：[3,2]输出：-1</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：[2,2,1,1,1,2,2]输出：2</code></pre><p><strong>说明：</strong><br>你有办法在时间复杂度为 O(N)，空间复杂度为 O(1) 内完成吗？</p><p>通过次数13,487</p><p>提交次数20,963</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public int majorityElement(int[] nums) &#123;        if(nums.length ==1) return nums[0];        int MidLens = nums.length / 2;        HashMap&lt;Integer, Integer&gt; m = new HashMap&lt;&gt;();        for(int i =0; i&lt; nums.length; i++)&#123;            if(m.containsKey( nums[i]))&#123;                Integer temp = m.get(nums[i]);                temp++;                if(temp &gt; MidLens) return nums[i];                m.put(nums[i], temp);            &#125;else&#123;                m.put(nums[i],1);            &#125;        &#125;        return -1;    &#125;&#125;</code></pre><pre><code class="python">class Solution:    def majorityElement(self, nums: List[int]) -&gt; int:        if len(nums) ==1 : return nums[0]        mid = len(nums) // 2        m = &#123;&#125;        for i in nums:            if i in m:                count = m[i]                count +=1                if(count &gt; mid): return i                m[i] = count             else:                m[i] = 1        return -1</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1260. 二维网格迁移</title>
      <link href="2020/09/14/1260.%20%E4%BA%8C%E7%BB%B4%E7%BD%91%E6%A0%BC%E8%BF%81%E7%A7%BB/"/>
      <url>2020/09/14/1260.%20%E4%BA%8C%E7%BB%B4%E7%BD%91%E6%A0%BC%E8%BF%81%E7%A7%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="1260-二维网格迁移"><a href="#1260-二维网格迁移" class="headerlink" title="1260. 二维网格迁移"></a><a href="https://leetcode-cn.com/problems/shift-2d-grid/">1260. 二维网格迁移</a></h1><p>难度简单32</p><p>给你一个 <code>m</code> 行 <code>n</code> 列的二维网格 <code>grid</code> 和一个整数 <code>k</code>。你需要将 <code>grid</code> 迁移 <code>k</code> 次。</p><p>每次「迁移」操作将会引发下述活动：</p><ul><li>位于 <code>grid[i][j]</code> 的元素将会移动到 <code>grid[i][j + 1]</code>。</li><li>位于 <code>grid[i][n - 1]</code> 的元素将会移动到 <code>grid[i + 1][0]</code>。</li><li>位于 <code>grid[m - 1][n - 1]</code> 的元素将会移动到 <code>grid[0][0]</code>。</li></ul><p>请你返回 <code>k</code> 次迁移操作后最终得到的 <strong>二维网格</strong>。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/16/e1-1.png" alt="img"></p><pre><code>输入：grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1输出：[[9,1,2],[3,4,5],[6,7,8]]</code></pre><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/16/e2-1.png" alt="img"></p><pre><code>输入：grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4输出：[[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9输出：[[1,2,3],[4,5,6],[7,8,9]]</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= grid.length &lt;= 50</code></li><li><code>1 &lt;= grid[i].length &lt;= 50</code></li><li><code>-1000 &lt;= grid[i][j] &lt;= 1000</code></li><li><code>0 &lt;= k &lt;= 100</code></li></ul><p>通过次数6,902</p><p>提交次数11,429</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; shiftGrid(int[][] grid, int k) &#123;        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();        int m = grid.length;        int n = grid[0].length;        int[][] ret= new int[m][n];        for(int i =0; i &lt; m;i++)&#123;            for(int j =0; j &lt; n; j++)&#123;                ret[((j + k )/n +i) % m  ][ (j +k) % n] = grid[i][j];            &#125;        &#125;        for(int i =0 ; i &lt; ret.length;i++)&#123;            List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();            for(int j=0; j&lt; ret[0].length; j++)&#123;                temp.add(ret[i][j]);            &#125;            res.add(temp);        &#125;        return res;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>225. 用队列实现栈</title>
      <link href="2020/09/14/225.%20%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
      <url>2020/09/14/225.%20%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h1><p>难度简单223收藏分享切换为英文关注反馈</p><p>使用队列实现栈的下列操作：</p><ul><li>push(x) – 元素 x 入栈</li><li>pop() – 移除栈顶元素</li><li>top() – 获取栈顶元素</li><li>empty() – 返回栈是否为空</li></ul><p><strong>注意:</strong></p><ul><li>你只能使用队列的基本操作– 也就是 <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code>, 和 <code>is empty</code> 这些操作是合法的。</li><li>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li><li>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</li></ul><p>通过次数72,158</p><p>提交次数110,101</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class MyStack &#123;    LinkedList&lt;Integer&gt; queue1 = new LinkedList&lt;&gt;();    LinkedList&lt;Integer&gt; queue2 = new LinkedList&lt;&gt;();    /** Initialize your data structure here. */    public MyStack() &#123;    &#125;    /** Push element x onto stack. */    public void push(int x) &#123;        queue1.add(x);    &#125;    /** Removes the element on top of the stack and returns that element. */    public int pop() &#123;        while(queue1.size() &gt;1)&#123;            queue2.add(queue1.pollFirst());        &#125;        Integer ret = queue1.pollFirst();        while(!queue2.isEmpty())&#123;            queue1.add(queue2.pollFirst());        &#125;        return ret;    &#125;    /** Get the top element. */    public int top() &#123;        while(queue1.size() &gt;1)&#123;            queue2.add(queue1.pollFirst());        &#125;        Integer ret = queue1.peekFirst();        queue2.add(queue1.pollFirst());        while(!queue2.isEmpty())&#123;            queue1.add(queue2.pollFirst());        &#125;        return ret;    &#125;    /** Returns whether the stack is empty. */    public boolean empty() &#123;        return queue1.isEmpty();    &#125;&#125;/** * Your MyStack object will be instantiated and called as such: * MyStack obj = new MyStack(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.top(); * boolean param_4 = obj.empty(); */</code></pre><p>利用双队列来模拟栈</p><p>注意点， 始终保持queue1为主队列</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 栈，队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1576. 替换所有的问号</title>
      <link href="2020/09/14/1576.%20%E6%9B%BF%E6%8D%A2%E6%89%80%E6%9C%89%E7%9A%84%E9%97%AE%E5%8F%B7/"/>
      <url>2020/09/14/1576.%20%E6%9B%BF%E6%8D%A2%E6%89%80%E6%9C%89%E7%9A%84%E9%97%AE%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="1576-替换所有的问号"><a href="#1576-替换所有的问号" class="headerlink" title="1576. 替换所有的问号"></a><a href="https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/">1576. 替换所有的问号</a></h1><p>难度简单5收藏分享切换为英文关注反馈</p><p>给你一个仅包含小写英文字母和 <code>&#39;?&#39;</code> 字符的字符串 <code>s</code>，请你将所有的 <code>&#39;?&#39;</code> 转换为若干小写字母，使最终的字符串不包含任何 <strong>连续重复</strong> 的字符。</p><p>注意：你 <strong>不能</strong> 修改非 <code>&#39;?&#39;</code> 字符。</p><p>题目测试用例保证 <strong>除</strong> <code>&#39;?&#39;</code> 字符 <strong>之外</strong>，不存在连续重复的字符。</p><p>在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。</p><p><strong>示例 1：</strong></p><pre><code class="java">输入：s = &quot;?zs&quot;输出：&quot;azs&quot;解释：该示例共有 25 种解决方案，从 &quot;azs&quot; 到 &quot;yzs&quot; 都是符合题目要求的。只有 &quot;z&quot; 是无效的修改，因为字符串 &quot;zzs&quot; 中有连续重复的两个 &#39;z&#39; 。</code></pre><p><strong>示例 2：</strong></p><pre><code class="java">输入：s = &quot;ubv?w&quot;输出：&quot;ubvaw&quot;解释：该示例共有 24 种解决方案，只有替换成 &quot;v&quot; 和 &quot;w&quot; 不符合题目要求。因为 &quot;ubvvw&quot; 和 &quot;ubvww&quot; 都包含连续重复的字符。</code></pre><p><strong>示例 3：</strong></p><pre><code class="java">输入：s = &quot;j?qg??b&quot;输出：&quot;jaqgacb&quot;</code></pre><p><strong>示例 4：</strong></p><pre><code class="java">输入：s = &quot;??yw?ipkj?&quot;输出：&quot;acywaipkja&quot;</code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> 仅包含小写英文字母和 <code>&#39;?&#39;</code> 字符</li></ul><p>通过次数5,305</p><p>提交次数10,740</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre><code class="java">class Solution &#123;    public String modifyString(String s) &#123;        char[] str = s.toCharArray();        char[] strList = &#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;g&#39;,&#39;i&#39;,&#39;j&#39;,&#39;k&#39;,&#39;l&#39;,                &#39;m&#39;,&#39;n&#39;,&#39;o&#39;,&#39;p&#39;,&#39;q&#39;,                &#39;r&#39;,&#39;s&#39;,&#39;t&#39;,&#39;u&#39;,&#39;v&#39;,&#39;w&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;&#125;;        for( int i=0; i &lt; str.length; i++)&#123;            if(str[i] ==&#39;?&#39;)&#123;                char l;                char r;                if(i==0 )&#123;                    l =  &#39; &#39;;                &#125;else&#123;                    l = str[i-1];                &#125;                if(i == str.length-1 )&#123;                    r = &#39; &#39;;                &#125;else&#123;                    r = str[i+1];                &#125;                str[i] = &#39;a&#39;;                for(int j =1; j &lt; strList.length;j++)&#123;                    if( l == str[i] || r == str[i])&#123;                        str[i] = strList[j];                    &#125;else&#123;                        break;                    &#125;                &#125;            &#125;        &#125;        return new String(str);    &#125;&#125;</code></pre><p>关键点：</p><ol><li>遍历的时候，主要将左右边界进行初始化判断</li><li>对于<code>?</code>被替换的值，可以初始化为<code>a</code></li></ol><p>优化解法</p><pre><code class="java">class Solution &#123;    public String modifyString(String s) &#123;        char[] chars = s.toCharArray();        for (int i = 0; i &lt; chars.length; i++) &#123;            if (chars[i] == &#39;?&#39;) &#123;                //前面一个字符  如果当前是第0个的话 字符就为‘ ’                char ahead = i == 0 ? &#39; &#39; : chars[i - 1];                //后面一个字符  如果当前是最后一个的话 字符就为‘ ’                char behind  = i == chars.length - 1 ? &#39; &#39; : chars[i + 1];                //从a开始比较  如果对于前面或者后面的话 就+1                char temp = &#39;a&#39;;                while (temp == ahead || temp == behind ) &#123;                    temp++;                &#125;                //找到目标字符后 做替换                chars[i] = temp;            &#125;        &#125;        return new String(chars);    &#125;&#125;</code></pre><p>在String前后添加占位字符</p><pre><code class="java">class Solution &#123;    public String modifyString(String s) &#123;        char[] str = (&#39;0&#39; + s +&#39;0&#39;).toCharArray();        for(int i =1;i &lt; str.length-1 ;i++)&#123;            if(str[i] ==&#39;?&#39;)&#123;                char left = str[i-1];                char right = str[i+1];                char temp = &#39;a&#39;;                while( left== temp || right == temp) temp++;                str[i] = temp;            &#125;        &#125;        return new String(str,1,str.length-2);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
